<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway Track Visualization</title>
    <style>
        body { margin: 0; padding: 20px; background-color: #000000; font-family: Arial, sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 20px; color: #ffffff; }
        .svg-container { background-color: #000000; border: 2px solid #ffffff; padding: 20px; display: flex; justify-content: center; }
        svg { background-color: #000000; border: 1px solid #ffffff; }
        .controls { margin-top: 30px; padding: 20px; background-color: #000000; border: 2px solid #ffffff; color: #ffffff; }
        .controls.disabled { opacity: 0.4; pointer-events: none; }
        .track-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; }
        .track-item { display: flex; flex-direction: column; gap: 8px; padding: 10px; border: 1px solid #ffffff; background-color: #1a1a1a; }
        .track-name { font-weight: bold; font-size: 14px; text-align: center; color: #ffffff; }
        .track-btn { padding: 8px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; transition: all 0.2s; }
        .track-btn:hover { opacity: 0.8; }
        .track-btn.off { background-color: transparent; color: #ffffff; }
        .track-btn.white { background-color: #ffffff; color: #000; }
        .track-btn.green { background-color: #00ff00; color: #000; }
        .track-btn.red { background-color: #ff0000; color: #fff; }
        .track-btn.yellow { background-color: #ffff00; color: #000; }
        .track-btn.broken { background-color: transparent; color: #ffff00; border-color: #ffff00; }
        .track-btn.magenta { background-color: #ff00ff; color: #fff; }
        .btn-group { display: flex; gap: 5px; }
        .btn-group button { flex: 1; padding: 6px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; background-color: #333; color: #ffffff; }
        .btn-group button.active { background-color: #0066cc; color: #fff; }
        .section-title { grid-column: 1 / -1; font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #ffffff; color: #ffffff; }
        @keyframes flash1Hz {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        .broken-ring { animation: flash1Hz 1s infinite; }
        .top-controls { display: flex; gap: 20px; margin-bottom: 30px; align-items: center; justify-content: center; }
        .control-group { display: flex; gap: 15px; align-items: center; }
        .control-group label { font-weight: bold; color: #ffffff; font-size: 16px; }
        .control-switch { display: flex; gap: 10px; }
        .control-switch button { padding: 10px 20px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; transition: all 0.2s; min-width: 80px; }
        .control-switch button.inactive { background-color: #333; color: #ffffff; }
        .control-switch button.active { background-color: #0066cc; color: #ffffff; }
        .power-button { padding: 12px 30px; border: 3px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 6px; font-size: 16px; transition: all 0.3s; min-width: 100px; }
        .power-button.on { background-color: #00ff00; color: #000; }
        .power-button.off { background-color: #ff0000; color: #fff; }
        .power-button:hover { transform: scale(1.05); }
        .system-status { color: #00ff00; font-weight: bold; font-size: 14px; }
        .system-status.off { color: #ff0000; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Railway Track Visualization - Domino Panel</h1>
        <div class="top-controls">
            <div class="control-group">
                <label>POWER:</label>
                <button class="power-button on" id="powerBtn">ON</button>
            </div>
            <div class="control-group">
                <label>MODE:</label>
                <div class="control-switch">
                    <button class="active" id="vduBtn">VDU</button>
                    <button class="inactive" id="dominoBtn">DOMINO</button>
                </div>
            </div>
            <div id="systemStatus" class="system-status">SYSTEM: READY</div>
        </div>
        <div class="svg-container">
            <svg id="trackSvg" width="1440" height="350" viewBox="0 0 1440 350"></svg>
        </div>
        <div id="routeLog" style="background-color: #000000; border: 2px solid #00ff00; padding: 15px; margin-top: 20px; max-height: 150px; overflow-y: auto; font-family: monospace; color: #00ff00; font-size: 12px; white-space: pre-wrap; word-wrap: break-word;">
            <div style="font-weight: bold; margin-bottom: 10px;">ROUTE LOG:</div>
        </div>
        <div class="controls">
            <h2>Controls</h2>
            <div class="track-controls" id="trackControls"></div>
        </div>
    </div>

    <script>
        // ╔══════════════════════════════════════════════════════════════╗
        // ║           RAILWAY TRACK VISUALIZATION - REFACTORED          ║
        // ║                   Clean, Maintainable Code                   ║
        // ╚══════════════════════════════════════════════════════════════╝

        // ════════════════════════════════════════════════════════════════
        // 1. CONFIGURATION & CONSTANTS
        // ════════════════════════════════════════════════════════════════

        /**
         * Main configuration object containing all dimensions and layout constants
         * @const {Object}
         */
        const CONFIG = {
            // Canvas dimensions
            SVG_WIDTH: 1440,
            SVG_HEIGHT: 350,

            // Track dimensions
            TRACK_WIDTH: 10,
            TRACK_STANDARD_WIDTH: 193,
            TRACK_EXTENDED_WIDTH: 331,
            TRACK_SHORTENED_WIDTH: 161,

            // Layout positions
            TRACK_UPPER_Y: 100,
            TRACK_LOWER_Y: 250,

            // Triangle/Signal markers
            TRIANGLE_SIZE: 12,
            TRIANGLE_GAP: 8,
            TRIANGLE_OFFSET: 24,

            // Vertical gap lines
            GAP_LINE_WIDTH: 8,
            GAP_LINE_HEIGHT: 18,

            // Signal components
            SIGNAL_POLE_WIDTH: 3,
            SIGNAL_POLE_HEIGHT: 20,
            SIGNAL_LAMP_RADIUS: 10,
            SIGNAL_ARM_LENGTH: 20,
            SIGNAL_HOOD_ARM_LENGTH: 8,
            SIGNAL_HOOD_RADIUS_MULTIPLIER: 1.3,
            SIGNAL_BROKEN_RING_OFFSET: 4,

            // Signal positions
            SIGNAL_POLE_Y_OFFSET_TOP: 20,
            SIGNAL_POLE_Y_OFFSET_BOTTOM: 40,

            // Hood decoration
            HOOD_DIAGONAL_GAP_APEX: 5,
            HOOD_DIAGONAL_GAP_ARC: 7,
            HOOD_FILL_COLOR: '#0066ff',

            // Shunt route symbol
            SHUNT_SYMBOL_SIZE: 10,
            SHUNT_SYMBOL_OFFSET: 10,
            SHUNT_SYMBOL_DIAGONAL_LENGTH: 0.8,

            // Platform dimensions
            PLATFORM_WIDTH: 100,
            PLATFORM_Y_OFFSET: 20,
            PLATFORM_LABEL_OFFSET: 50,

            // Switch dimensions
            SWITCH_SECTION_WIDTH: 40,
            SWITCH_OVERLAP: 10,
            SWITCH_NORMAL_SHORTENING: 50,
            SWITCH_INDICATOR_RADIUS: 8,

            // Diagonal track
            DIAG_GAP_DISTANCE: 4,
            DIAG_OFFSET: 2,

            // Label positioning
            LABEL_Y_OFFSET_UPPER: 30,
            LABEL_Y_OFFSET_LOWER: 30,
            LABEL_SIGNAL_OFFSET: 25,
            LABEL_SIGNAL_Y_OFFSET: 6,
            LABEL_BG_WIDTH: 30,
            LABEL_BG_HEIGHT: 18,
            LABEL_BG_RADIUS: 2,
            LABEL_END_OFFSET: 50
        };

        /**
         * Color definitions for different track and signal states
         * @const {Object}
         */
        const COLORS = {
            OFF: '#ff00ff',      // Magenta
            WHITE: '#ffffff',
            GREEN: '#00ff00',
            RED: '#ff0000',
            YELLOW: '#ffff00',
            BLACK: '#000000'
        };

        // ════════════════════════════════════════════════════════════════
        // 2. STATE MANAGEMENT
        // ════════════════════════════════════════════════════════════════

        /**
         * Global application state
         * @type {Object}
         */
        const state = {
            power: 'on',
            mode: 'vdu',
            tracks: {
                VA: 'white', VB: 'white', VC_LEFT: 'white', VC_11A: 'white', VC_RIGHT: 'white', VD: 'white',
                AD: 'white', AC: 'white', AB_LEFT: 'white', AB_11B: 'white', AB_RIGHT: 'white', AA: 'white',
                DIAG: 'white'
            },
            signals: {
                N4: 'off',
                T7: 'off',
                S6: 'off',
                T5: 'off',
                T3: 'off'
            },
            hoods: {
                T5: 'empty',
                T3: 'empty',
                S6: 'empty'
            },
            switches: {
                '11A': 'NORMAL',
                '11B': 'NORMAL'
            },
            switchStates: {
                '11A': 'OK',
                '11B': 'OK'
            }
        };

        /**
         * Route selection and logging state
         * @type {Object}
         */
        const routeState = {
            selectedTriangle: null,
            routeLog: []
        };

        // ════════════════════════════════════════════════════════════════
        // 3. ROUTE VALIDATION
        // ════════════════════════════════════════════════════════════════

        /**
         * Valid route combinations based on track topology
         * @const {Object}
         */
        const VALID_ROUTES = {
            'N4-Utara Direction': ['T3-Utara Direction'],
            'T3-Selatan Direction': ['N4-Selatan Direction', 'T7-Selatan Direction'],
            'T5-Selatan Direction': ['T7-Selatan Direction']
        };

        /**
         * Error messages for specific invalid routes
         * @const {Object}
         */
        const INVALID_ROUTE_MESSAGES = {
            'N4-Selatan Direction|T3-Selatan Direction': 'wrong sequence',
            'T3-Utara Direction|N4-Utara Direction': 'wrong sequence',
            'T5-Utara Direction|T7-Utara Direction': 'no Utara triangle',
            'T7-Selatan Direction|T5-Selatan Direction': 'wrong sequence',
            'T7-Utara Direction|T5-Utara Direction': 'no Utara triangle',
            'T3-Selatan Direction|T5-Selatan Direction': 'impossible',
            'T3-Utara Direction|T7-Utara Direction': 'no Utara triangle',
            'T5-Selatan Direction|T3-Selatan Direction': 'impossible',
            'T7-Selatan Direction|T3-Selatan Direction': 'wrong sequence'
        };

        /**
         * Valid shunt signal connections
         * @const {Object}
         */
        const VALID_SHUNT_CONNECTIONS = {
            'S6': ['T5', 'T3'],
            'T5': ['S6'],
            'T3': ['S6']
        };

        /**
         * Check if a route is valid
         * @param {string} fromSignal - Starting signal name
         * @param {string} fromDirection - Starting direction
         * @param {string} toSignal - Ending signal name
         * @param {string} toDirection - Ending direction
         * @returns {boolean} True if route is valid
         */
        function isValidRoute(fromSignal, fromDirection, toSignal, toDirection) {
            const fromKey = `${fromSignal}-${fromDirection}`;
            const toKey = `${toSignal}-${toDirection}`;
            return VALID_ROUTES[fromKey]?.includes(toKey) || false;
        }

        /**
         * Check if a shunt route connection is valid
         * @param {string} fromSignal - Starting signal name
         * @param {string} toSignal - Ending signal name
         * @returns {boolean} True if shunt route is valid
         */
        function isValidShuntRoute(fromSignal, toSignal) {
            if (fromSignal === toSignal) return false;
            return VALID_SHUNT_CONNECTIONS[fromSignal]?.includes(toSignal) || false;
        }

        /**
         * Get error message for invalid route
         * @param {string} fromSignal - Starting signal
         * @param {string} fromDirection - Starting direction
         * @param {string} toSignal - Ending signal
         * @param {string} toDirection - Ending direction
         * @returns {string} Error message
         */
        function getInvalidRouteMessage(fromSignal, fromDirection, toSignal, toDirection) {
            const routeKey = `${fromSignal}-${fromDirection}|${toSignal}-${toDirection}`;
            return INVALID_ROUTE_MESSAGES[routeKey] || 'invalid route';
        }

        /**
         * Log a route attempt
         * @param {string} fromSignal - Starting signal
         * @param {string} fromDirection - Starting direction
         * @param {string} toSignal - Ending signal
         * @param {string} toDirection - Ending direction
         * @param {boolean} isValid - Whether route is valid
         * @param {string} errorMessage - Error message if invalid
         */
        function logRoute(fromSignal, fromDirection, toSignal, toDirection, isValid = true, errorMessage = '') {
            const routeString = isValid
                ? `Route set: ${fromSignal} ${fromDirection} --> ${toSignal} ${toDirection}`
                : `Invalid route: ${fromSignal} ${fromDirection} --> ${toSignal} ${toDirection} (${errorMessage})`;

            routeState.routeLog.push(routeString);
            console.log(routeString);

            const logContainer = document.getElementById('routeLog');
            if (logContainer) {
                const logEntry = document.createElement('div');
                logEntry.textContent = routeString;
                logEntry.style.color = isValid ? '#00ff00' : '#ff0000';
                logEntry.style.fontFamily = 'monospace';
                logEntry.style.padding = '5px';
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
        }

        /**
         * Handle triangle click for route selection
         * @param {string} signalName - Signal name
         * @param {string} direction - Direction
         */
        function handleTriangleClick(signalName, direction) {
            if (state.power === 'off') {
                console.log('Cannot set routes - system power is OFF');
                return;
            }

            if (!routeState.selectedTriangle) {
                routeState.selectedTriangle = { signalName, direction, isShunt: false };
                console.log(`Route origin selected: ${signalName} ${direction}`);
            } else {
                const from = routeState.selectedTriangle;

                if (from.isShunt) {
                    logRoute(from.signalName, from.direction, signalName, direction, false, 'Cannot connect shunt route to main route');
                } else {
                    if (isValidRoute(from.signalName, from.direction, signalName, direction)) {
                        logRoute(from.signalName, from.direction, signalName, direction, true);
                    } else {
                        const errorMessage = getInvalidRouteMessage(from.signalName, from.direction, signalName, direction);
                        logRoute(from.signalName, from.direction, signalName, direction, false, errorMessage);
                    }
                }

                routeState.selectedTriangle = null;
            }
        }

        /**
         * Handle shunt route click
         * @param {string} signalName - Signal name
         * @param {string} routeType - Route type
         */
        function handleShuntRouteClick(signalName, routeType) {
            if (state.power === 'off') {
                console.log('Cannot set shunt routes - system power is OFF');
                return;
            }

            if (!routeState.selectedTriangle) {
                routeState.selectedTriangle = { signalName, direction: routeType, isShunt: true };
                console.log(`Shunt route origin selected: ${signalName} ${routeType}`);
            } else {
                const from = routeState.selectedTriangle;

                if (from.isShunt && routeType === 'Shunt') {
                    if (isValidShuntRoute(from.signalName, signalName)) {
                        logRoute(from.signalName, from.direction, signalName, routeType, true);
                    } else {
                        logRoute(from.signalName, from.direction, signalName, routeType, false, `Shunt route ${from.signalName} cannot connect to ${signalName}`);
                    }
                } else if (!from.isShunt) {
                    logRoute(from.signalName, from.direction, signalName, routeType, false, 'Cannot connect main route to shunt route');
                } else {
                    logRoute(from.signalName, from.direction, signalName, routeType, false, 'Shunt routes can only connect to other shunt routes');
                }

                routeState.selectedTriangle = null;
            }
        }

        // ════════════════════════════════════════════════════════════════
        // 4. COLOR & UTILITY FUNCTIONS
        // ════════════════════════════════════════════════════════════════

        /**
         * Get color for track state
         * @param {string} trackState - Track state
         * @returns {string} Color hex code
         */
        function getColor(trackState) {
            if (state.power === 'off') return COLORS.OFF;

            const colorMap = {
                'green': COLORS.GREEN,
                'red': COLORS.RED,
                'yellow': COLORS.YELLOW,
                'white': COLORS.WHITE,
                'magenta': COLORS.OFF
            };
            return colorMap[trackState] || COLORS.OFF;
        }

        /**
         * Get color for signal state
         * @param {string} signalState - Signal state
         * @returns {string} Color hex code or 'none'
         */
        function getSignalColor(signalState) {
            if (state.power === 'off') return 'none';

            const colorMap = {
                'green': COLORS.GREEN,
                'red': COLORS.RED,
                'yellow': COLORS.YELLOW,
                'white': COLORS.WHITE
            };
            return colorMap[signalState] || 'none';
        }

        /**
         * Get default color based on power state
         * @returns {string} Color hex code
         */
        function getDefaultColor() {
            return state.power === 'off' ? COLORS.OFF : COLORS.WHITE;
        }

        /**
         * Get SVG namespace for element creation
         * @returns {string} SVG namespace URL
         */
        function getSVGNamespace() {
            return 'http://www.w3.org/2000/svg';
        }

        // ════════════════════════════════════════════════════════════════
        // 5. SVG DRAWING PRIMITIVES
        // ════════════════════════════════════════════════════════════════

        /**
         * Create SVG element with namespace
         * @param {string} type - Element type
         * @returns {SVGElement} Created element
         */
        function createSVGElement(type) {
            return document.createElementNS(getSVGNamespace(), type);
        }

        /**
         * Set multiple attributes on an element
         * @param {Element} element - Target element
         * @param {Object} attributes - Attribute key-value pairs
         */
        function setAttributes(element, attributes) {
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
        }

        /**
         * Draw a track section line
         * @param {SVGElement} svg - SVG container
         * @param {number} x1 - Start X
         * @param {number} x2 - End X
         * @param {number} y - Y position
         * @param {string} trackName - Track name for state lookup
         */
        function drawTrackSection(svg, x1, x2, y, trackName) {
            const line = createSVGElement('line');
            setAttributes(line, {
                x1, y1: y, x2, y2: y,
                stroke: getColor(state.tracks[trackName]),
                'stroke-width': CONFIG.TRACK_WIDTH,
                'stroke-linecap': 'butt'
            });
            svg.appendChild(line);
        }

        /**
         * Draw a text label
         * @param {SVGElement} svg - SVG container
         * @param {number} x - X position
         * @param {number} y - Y position
         * @param {string} text - Label text
         */
        function drawLabel(svg, x, y, text) {
            const label = createSVGElement('text');
            setAttributes(label, {
                x, y,
                'text-anchor': 'middle',
                'font-size': '14',
                'font-weight': 'bold',
                fill: getDefaultColor()
            });
            label.textContent = text;
            svg.appendChild(label);
        }

        /**
         * Draw a vertical gap line
         * @param {SVGElement} svg - SVG container
         * @param {number} x - X position
         * @param {number} y - Y position (center)
         */
        function drawVerticalGapLine(svg, x, y) {
            const rect = createSVGElement('rect');
            setAttributes(rect, {
                x,
                y: y - CONFIG.GAP_LINE_HEIGHT / 2,
                width: CONFIG.GAP_LINE_WIDTH,
                height: CONFIG.GAP_LINE_HEIGHT,
                fill: getDefaultColor(),
                stroke: 'none'
            });
            svg.appendChild(rect);
        }

        /**
         * Draw a triangle marker
         * @param {SVGElement} svg - SVG container
         * @param {number} x - X position (center)
         * @param {number} y - Y position
         * @param {string} direction - 'left' or 'right'
         * @param {Function} clickHandler - Click handler function
         */
        function drawTriangle(svg, x, y, direction, clickHandler) {
            const size = CONFIG.TRIANGLE_SIZE;
            const triangle = createSVGElement('polygon');

            const points = direction === 'right'
                ? `${x - size},${y - size} ${x - size},${y + size} ${x + size},${y}`
                : `${x + size},${y - size} ${x + size},${y + size} ${x - size},${y}`;

            setAttributes(triangle, {
                points,
                fill: state.power === 'off' ? COLORS.OFF : COLORS.WHITE,
                stroke: getDefaultColor(),
                'stroke-width': '2',
                cursor: 'pointer'
            });

            triangle.onclick = clickHandler;
            svg.appendChild(triangle);
        }

        /**
         * Draw a shunt route symbol (_\)
         * @param {SVGElement} svg - SVG container
         * @param {number} x - X position
         * @param {number} y - Y position
         * @param {string} signalName - Signal name
         * @param {boolean} flipHorizontal - Flip horizontally
         * @param {boolean} flipVertical - Flip vertically
         */
        function drawShuntSymbol(svg, x, y, signalName, flipHorizontal = false, flipVertical = false) {
            const size = CONFIG.SHUNT_SYMBOL_SIZE;
            const hDir = flipHorizontal ? -1 : 1;
            const vDir = flipVertical ? 1 : -1;

            // Horizontal line
            const horizontal = createSVGElement('line');
            setAttributes(horizontal, {
                x1: x,
                y1: y,
                x2: x + size * hDir,
                y2: y,
                stroke: getDefaultColor(),
                'stroke-width': '2',
                'stroke-linecap': 'round',
                cursor: 'pointer'
            });
            horizontal.onclick = () => handleShuntRouteClick(signalName, 'Shunt');
            svg.appendChild(horizontal);

            // Diagonal line
            const diagonal = createSVGElement('line');
            setAttributes(diagonal, {
                x1: x + size * hDir,
                y1: y,
                x2: x + size * hDir / 5,
                y2: y + size * CONFIG.SHUNT_SYMBOL_DIAGONAL_LENGTH * vDir,
                stroke: getDefaultColor(),
                'stroke-width': '2',
                'stroke-linecap': 'round',
                cursor: 'pointer'
            });
            diagonal.onclick = () => handleShuntRouteClick(signalName, 'Shunt');
            svg.appendChild(diagonal);
        }

        /**
         * Draw a platform
         * @param {SVGElement} svg - SVG container
         * @param {number} x - X position
         * @param {number} topY - Top Y position
         * @param {number} bottomY - Bottom Y position
         * @param {string} label - Platform label
         */
        function drawPlatform(svg, x, topY, bottomY, label) {
            const rect = createSVGElement('rect');
            setAttributes(rect, {
                x,
                y: topY,
                width: CONFIG.PLATFORM_WIDTH,
                height: bottomY - topY,
                fill: 'none',
                stroke: getDefaultColor(),
                'stroke-width': '2'
            });
            svg.appendChild(rect);

            drawLabel(svg, x + CONFIG.PLATFORM_WIDTH / 2, topY + (bottomY - topY) / 2, label);
        }

        /**
         * Draw a signal with all components
         * @param {SVGElement} svg - SVG container
         * @param {Object} config - Signal configuration
         */
        function drawSignal(svg, config) {
            const {
                name,
                poleX,
                poleYTop,
                lampX,
                lampY,
                labelX,
                labelY,
                hasHood = false,
                hoodConfig = null,
                cycleHandler
            } = config;

            // Pole
            const pole = createSVGElement('line');
            setAttributes(pole, {
                x1: poleX, y1: poleYTop,
                x2: poleX, y2: poleYTop + CONFIG.SIGNAL_POLE_HEIGHT,
                stroke: getDefaultColor(),
                'stroke-width': CONFIG.SIGNAL_POLE_WIDTH
            });
            svg.appendChild(pole);

            // Lamp or Hood
            if (hasHood && hoodConfig) {
                drawSignalWithHood(svg, name, lampX, lampY, poleX, hoodConfig, cycleHandler);
            } else {
                // Lamp arm
                const arm = createSVGElement('line');
                const armEndX = lampX > poleX ? lampX - CONFIG.SIGNAL_LAMP_RADIUS : lampX + CONFIG.SIGNAL_LAMP_RADIUS;
                setAttributes(arm, {
                    x1: poleX, y1: lampY,
                    x2: armEndX, y2: lampY,
                    stroke: getDefaultColor(),
                    'stroke-width': '2'
                });
                svg.appendChild(arm);

                // Lamp
                const lamp = createSVGElement('circle');
                setAttributes(lamp, {
                    cx: lampX,
                    cy: lampY,
                    r: CONFIG.SIGNAL_LAMP_RADIUS,
                    fill: state.signals[name] === 'broken' ? 'none' : getSignalColor(state.signals[name]),
                    stroke: getDefaultColor(),
                    'stroke-width': '2',
                    cursor: 'pointer'
                });
                lamp.onclick = cycleHandler;
                svg.appendChild(lamp);

                // Broken indicator
                if (state.signals[name] === 'broken' && state.power === 'on') {
                    const brokenRing = createSVGElement('circle');
                    setAttributes(brokenRing, {
                        cx: lampX,
                        cy: lampY,
                        r: CONFIG.SIGNAL_LAMP_RADIUS + CONFIG.SIGNAL_BROKEN_RING_OFFSET,
                        fill: 'none',
                        stroke: COLORS.YELLOW,
                        'stroke-width': '2',
                        cursor: 'pointer',
                        class: 'broken-ring'
                    });
                    brokenRing.onclick = cycleHandler;
                    svg.appendChild(brokenRing);
                }
            }

            // Label with background
            const bgRect = createSVGElement('rect');
            setAttributes(bgRect, {
                x: labelX - CONFIG.LABEL_BG_WIDTH / 2,
                y: labelY - CONFIG.LABEL_BG_HEIGHT / 2 - CONFIG.LABEL_SIGNAL_Y_OFFSET,
                width: CONFIG.LABEL_BG_WIDTH,
                height: CONFIG.LABEL_BG_HEIGHT,
                fill: state.power === 'on' ? COLORS.RED : 'none',
                rx: CONFIG.LABEL_BG_RADIUS
            });
            svg.appendChild(bgRect);

            drawLabel(svg, labelX, labelY, name);
        }

        /**
         * Draw signal with hood
         * @param {SVGElement} svg - SVG container
         * @param {string} name - Signal name
         * @param {number} lampX - Lamp X position
         * @param {number} lampY - Lamp Y position
         * @param {number} poleX - Pole X position
         * @param {Object} hoodConfig - Hood configuration
         * @param {Function} cycleHandler - Cycle handler
         */
        function drawSignalWithHood(svg, name, lampX, lampY, poleX, hoodConfig, cycleHandler) {
            const { direction } = hoodConfig;
            const radiusX = CONFIG.SIGNAL_POLE_HEIGHT * CONFIG.SIGNAL_HOOD_RADIUS_MULTIPLIER;
            const radiusY = CONFIG.SIGNAL_POLE_HEIGHT;

            let hoodCenterX, hoodCenterY, hoodPath, diagStartX, diagStartY, diagEndX, diagEndY;

            if (direction === 'left') {
                // Hood faces left (T3, T5)
                hoodCenterX = lampX + CONFIG.SIGNAL_LAMP_RADIUS + radiusX;
                hoodCenterY = lampY - CONFIG.SIGNAL_LAMP_RADIUS;
                hoodPath = `M ${hoodCenterX},${hoodCenterY} L ${hoodCenterX - radiusX},${hoodCenterY} A ${radiusX},${radiusY} 0 0,0 ${hoodCenterX},${hoodCenterY + radiusY} Z`;

                // Diagonal line for filled hood
                diagStartX = hoodCenterX - CONFIG.HOOD_DIAGONAL_GAP_APEX;
                diagStartY = hoodCenterY + CONFIG.HOOD_DIAGONAL_GAP_APEX;
                const diagDistance = Math.min(radiusX, radiusY) - CONFIG.HOOD_DIAGONAL_GAP_APEX - CONFIG.HOOD_DIAGONAL_GAP_ARC;
                diagEndX = diagStartX - diagDistance;
                diagEndY = diagStartY + diagDistance;
            } else {
                // Hood faces right (S6)
                hoodCenterX = poleX + CONFIG.SIGNAL_HOOD_ARM_LENGTH;
                hoodCenterY = lampY - CONFIG.SIGNAL_LAMP_RADIUS;
                hoodPath = `M ${hoodCenterX},${hoodCenterY + radiusY} L ${hoodCenterX + radiusX},${hoodCenterY + radiusY} A ${radiusX},${radiusY} 0 0,0 ${hoodCenterX},${hoodCenterY} Z`;

                // Diagonal line for filled hood
                diagStartX = hoodCenterX + CONFIG.HOOD_DIAGONAL_GAP_APEX;
                diagStartY = hoodCenterY + radiusY - CONFIG.HOOD_DIAGONAL_GAP_APEX;
                const diagDistance = Math.min(radiusX, radiusY) - CONFIG.HOOD_DIAGONAL_GAP_APEX - CONFIG.HOOD_DIAGONAL_GAP_ARC;
                diagEndX = diagStartX + diagDistance;
                diagEndY = diagStartY - diagDistance;
            }

            // Draw lamp (if not S6)
            if (lampX !== poleX) {
                const lamp = createSVGElement('circle');
                setAttributes(lamp, {
                    cx: lampX,
                    cy: lampY,
                    r: CONFIG.SIGNAL_LAMP_RADIUS,
                    fill: state.signals[name] === 'broken' ? 'none' : getSignalColor(state.signals[name]),
                    stroke: getDefaultColor(),
                    'stroke-width': '2',
                    cursor: 'pointer'
                });
                lamp.onclick = cycleHandler;
                svg.appendChild(lamp);

                // Broken indicator
                if (state.signals[name] === 'broken' && state.power === 'on') {
                    const brokenRing = createSVGElement('circle');
                    setAttributes(brokenRing, {
                        cx: lampX,
                        cy: lampY,
                        r: CONFIG.SIGNAL_LAMP_RADIUS + CONFIG.SIGNAL_BROKEN_RING_OFFSET,
                        fill: 'none',
                        stroke: COLORS.YELLOW,
                        'stroke-width': '2',
                        cursor: 'pointer',
                        class: 'broken-ring'
                    });
                    brokenRing.onclick = cycleHandler;
                    svg.appendChild(brokenRing);
                }
            }

            // Hood
            const hood = createSVGElement('path');
            setAttributes(hood, {
                d: hoodPath,
                fill: state.hoods[name] === 'filled' ? CONFIG.HOOD_FILL_COLOR : 'none',
                stroke: getDefaultColor(),
                'stroke-width': '2',
                'stroke-linejoin': 'miter',
                cursor: 'pointer'
            });
            hood.onclick = () => toggleHood(name);
            svg.appendChild(hood);

            // Diagonal line when filled
            if (state.hoods[name] === 'filled') {
                const diagLine = createSVGElement('line');
                setAttributes(diagLine, {
                    x1: diagStartX, y1: diagStartY,
                    x2: diagEndX, y2: diagEndY,
                    stroke: getDefaultColor(),
                    'stroke-width': '2'
                });
                svg.appendChild(diagLine);
            }

            // Arm
            const arm = createSVGElement('line');
            setAttributes(arm, {
                x1: poleX,
                y1: lampY,
                x2: hoodCenterX,
                y2: lampY,
                stroke: getDefaultColor(),
                'stroke-width': '2'
            });
            svg.appendChild(arm);
        }

        /**
         * Draw switch indicator (broken state)
         * @param {SVGElement} svg - SVG container
         * @param {string} switchName - Switch name
         * @param {number} x - X position
         * @param {number} y - Y position
         */
        function drawSwitchIndicator(svg, switchName, x, y) {
            if (state.switchStates[switchName] === 'broken' && state.power === 'on') {
                const circle = createSVGElement('circle');
                setAttributes(circle, {
                    cx: x,
                    cy: y,
                    r: CONFIG.SWITCH_INDICATOR_RADIUS,
                    fill: 'none',
                    stroke: COLORS.YELLOW,
                    'stroke-width': '2',
                    cursor: 'pointer',
                    class: 'broken-ring'
                });
                circle.onclick = () => toggleSwitchState(switchName);
                svg.appendChild(circle);
            }
        }

        // ════════════════════════════════════════════════════════════════
        // 6. MAIN TRACK RENDERING
        // ════════════════════════════════════════════════════════════════

        /**
         * Calculate track layout positions
         * @returns {Object} Layout positions and dimensions
         */
        function calculateTrackLayout() {
            const upperY = CONFIG.TRACK_UPPER_Y;
            const lowerY = CONFIG.TRACK_LOWER_Y;
            const standardWidth = CONFIG.TRACK_STANDARD_WIDTH;
            const extendedWidth = CONFIG.TRACK_EXTENDED_WIDTH;

            const totalTrackWidth = standardWidth + 40 + standardWidth + 8 + (extendedWidth + 40) + 40 + standardWidth;
            const startX = (CONFIG.SVG_WIDTH - totalTrackWidth) / 2;

            // Upper track positions
            const vaWidth = CONFIG.TRACK_SHORTENED_WIDTH;
            const vaEnd = startX + vaWidth;

            const vaVbTriangle1X = vaEnd + CONFIG.TRIANGLE_SIZE;
            const vaVbTriangle2X = vaEnd + CONFIG.TRIANGLE_OFFSET + CONFIG.TRIANGLE_GAP + CONFIG.TRIANGLE_SIZE;

            const vbStart = vaEnd + CONFIG.TRIANGLE_OFFSET + CONFIG.TRIANGLE_GAP + CONFIG.TRIANGLE_OFFSET;
            const vbEnd = vbStart + standardWidth;

            const vcStart = vbEnd + CONFIG.TRIANGLE_GAP;
            const vc11AStart = vcStart + extendedWidth * 0.75;
            const vc11AEnd = vc11AStart + CONFIG.SWITCH_SECTION_WIDTH;
            const vcLeftEnd = vc11AStart + CONFIG.SWITCH_OVERLAP;
            const vcRightStart = vc11AEnd - CONFIG.SWITCH_OVERLAP;
            const vcRightEnd = vcStart + extendedWidth + CONFIG.SWITCH_SECTION_WIDTH;
            const vcEnd = vcRightEnd;

            const vcVdTriangle1X = vcEnd + CONFIG.TRIANGLE_SIZE;
            const vcVdTriangle2X = vcEnd + CONFIG.TRIANGLE_OFFSET + CONFIG.TRIANGLE_GAP + CONFIG.TRIANGLE_SIZE;

            const vdStart = vcVdTriangle2X + CONFIG.TRIANGLE_SIZE;
            const vdWidth = CONFIG.TRACK_SHORTENED_WIDTH;
            const vdEnd = vdStart + vdWidth;

            // Lower track positions
            const adEnd = startX + standardWidth;
            const acStart = adEnd + CONFIG.TRIANGLE_OFFSET;
            const acEnd = vbEnd;

            const abStart = vbEnd + CONFIG.TRIANGLE_GAP;
            const vcRightSize = vcRightEnd - vcRightStart;
            const abLeftEnd = abStart + vcRightSize + 1;
            const ab11BStart = abLeftEnd - CONFIG.SWITCH_OVERLAP;
            const ab11BEnd = ab11BStart + CONFIG.SWITCH_SECTION_WIDTH;
            const abRightStart = ab11BEnd - CONFIG.SWITCH_OVERLAP;
            const abRightEnd = abStart + extendedWidth + CONFIG.SWITCH_SECTION_WIDTH;
            const abTriangleGapX = vcEnd + CONFIG.TRIANGLE_OFFSET;
            const abEnd = abTriangleGapX;

            const aaStart = vcVdTriangle2X + CONFIG.TRIANGLE_SIZE;
            const aaWidth = CONFIG.TRACK_SHORTENED_WIDTH;
            const aaEnd = aaStart + aaWidth;

            return {
                upperY, lowerY, startX,
                va: { start: startX, end: vaEnd, width: vaWidth },
                vb: { start: vbStart, end: vbEnd },
                vc: { start: vcStart, end: vcEnd, leftEnd: vcLeftEnd, rightStart: vcRightStart, rightEnd: vcRightEnd, switch11A: { start: vc11AStart, end: vc11AEnd } },
                vd: { start: vdStart, end: vdEnd, width: vdWidth },
                ad: { start: startX, end: adEnd },
                ac: { start: acStart, end: acEnd },
                ab: { start: abStart, end: abEnd, leftEnd: abLeftEnd, rightStart: abRightStart, rightEnd: abRightEnd, switch11B: { start: ab11BStart, end: ab11BEnd }, triangleGapX: abTriangleGapX },
                aa: { start: aaStart, end: aaEnd, width: aaWidth },
                triangles: {
                    vaVb: { triangle1X: vaVbTriangle1X, triangle2X: vaVbTriangle2X },
                    vcVd: { triangle1X: vcVdTriangle1X, triangle2X: vcVdTriangle2X }
                },
                vcRightSize
            };
        }

        /**
         * Draw upper track line (VA, VB, VC, VD)
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawUpperTrack(svg, layout) {
            const { upperY, va, vb, vc, vd } = layout;

            // VA
            drawTrackSection(svg, va.start, va.end, upperY, 'VA');
            drawLabel(svg, va.start + va.width / 2, upperY - CONFIG.LABEL_Y_OFFSET_UPPER, 'VA');

            // VB
            drawTrackSection(svg, vb.start, vb.end, upperY, 'VB');
            drawLabel(svg, vb.start + (vb.end - vb.start) / 2, upperY - CONFIG.LABEL_Y_OFFSET_UPPER, 'VB');

            // VC (with switch handling)
            if (state.switches['11A'] === 'NORMAL') {
                drawTrackSection(svg, vc.start, vc.rightEnd, upperY, 'VC_LEFT');
            } else {
                drawTrackSection(svg, vc.start, vc.leftEnd, upperY, 'VC_LEFT');
                drawTrackSection(svg, vc.rightStart, vc.rightEnd, upperY, 'VC_RIGHT');
            }
            drawLabel(svg, vc.start + 60, upperY - CONFIG.LABEL_Y_OFFSET_UPPER, 'VC');
            drawLabel(svg, vc.switch11A.start + 20, upperY - CONFIG.LABEL_Y_OFFSET_UPPER, '11A');

            // VD
            drawTrackSection(svg, vd.start, vd.end, upperY, 'VD');
            drawLabel(svg, vd.start + vd.width / 2, upperY - CONFIG.LABEL_Y_OFFSET_UPPER, 'VD');
        }

        /**
         * Draw lower track line (AD, AC, AB, AA)
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawLowerTrack(svg, layout) {
            const { lowerY, ad, ac, ab, aa } = layout;

            // AD
            drawTrackSection(svg, ad.start, ad.end, lowerY, 'AD');
            drawLabel(svg, ad.start + (ad.end - ad.start) / 2, lowerY + CONFIG.LABEL_Y_OFFSET_LOWER, 'AD');

            // AC
            drawTrackSection(svg, ac.start, ac.end, lowerY, 'AC');
            const acMidpoint = ac.start + (ac.end - ac.start) / 2;
            drawLabel(svg, acMidpoint, lowerY + CONFIG.LABEL_Y_OFFSET_LOWER, 'AC');

            // AB (with switch handling)
            if (state.switches['11B'] === 'NORMAL') {
                drawTrackSection(svg, ab.start, ab.triangleGapX, lowerY, 'AB_LEFT');
            } else {
                drawTrackSection(svg, ab.start, ab.leftEnd, lowerY, 'AB_LEFT');
                drawTrackSection(svg, ab.rightStart, ab.triangleGapX, lowerY, 'AB_RIGHT');
            }
            drawLabel(svg, ab.rightEnd - 60, lowerY + CONFIG.LABEL_Y_OFFSET_LOWER, 'AB');
            drawLabel(svg, ab.switch11B.start + 20, lowerY + CONFIG.LABEL_Y_OFFSET_LOWER, '11B');

            // AA
            drawTrackSection(svg, aa.start, aa.end, lowerY, 'AA');
            drawLabel(svg, aa.start + aa.width / 2, lowerY + CONFIG.LABEL_Y_OFFSET_LOWER, 'AA');
        }

        /**
         * Draw vertical gap lines
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawGapLines(svg, layout) {
            const { upperY, lowerY, vb, triangles } = layout;

            // Upper track gaps
            drawVerticalGapLine(svg, triangles.vaVb.triangle1X + (CONFIG.TRIANGLE_OFFSET - CONFIG.TRIANGLE_SIZE), upperY);
            drawVerticalGapLine(svg, vb.end, upperY);
            drawVerticalGapLine(svg, triangles.vcVd.triangle1X + (CONFIG.TRIANGLE_OFFSET - CONFIG.TRIANGLE_SIZE), upperY);

            // Lower track gaps
            drawVerticalGapLine(svg, triangles.vaVb.triangle1X + (CONFIG.TRIANGLE_OFFSET - CONFIG.TRIANGLE_SIZE), lowerY);
            drawVerticalGapLine(svg, vb.end, lowerY);
            drawVerticalGapLine(svg, triangles.vcVd.triangle1X + (CONFIG.TRIANGLE_OFFSET - CONFIG.TRIANGLE_SIZE), lowerY);
        }

        /**
         * Draw all triangles
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawTriangles(svg, layout) {
            const { upperY, lowerY, ad, triangles } = layout;

            // VA-VB triangles
            drawTriangle(svg, triangles.vaVb.triangle1X, upperY, 'right', () => handleTriangleClick('N4', 'Utara Direction'));
            drawTriangle(svg, triangles.vaVb.triangle2X, upperY, 'left', () => handleTriangleClick('N4', 'Selatan Direction'));

            // VC-VD triangles
            drawTriangle(svg, triangles.vcVd.triangle1X, upperY, 'right', () => handleTriangleClick('T3', 'Utara Direction'));
            drawTriangle(svg, triangles.vcVd.triangle2X, upperY, 'left', () => handleTriangleClick('T3', 'Selatan Direction'));

            // AD-AC triangle
            drawTriangle(svg, ad.end + CONFIG.TRIANGLE_SIZE, lowerY, 'left', () => handleTriangleClick('T7', 'Selatan Direction'));

            // AB-AA triangle
            drawTriangle(svg, triangles.vcVd.triangle2X, lowerY, 'left', () => handleTriangleClick('T5', 'Selatan Direction'));
        }

        /**
         * Draw all signals
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawSignals(svg, layout) {
            const { upperY, lowerY, va, vb, vc, ad, ab, triangles } = layout;

            // N4 - between VA and VB
            const n4PoleX = va.end + (vb.start - va.end) / 2;
            drawSignal(svg, {
                name: 'N4',
                poleX: n4PoleX,
                poleYTop: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP,
                lampX: n4PoleX + CONFIG.SIGNAL_ARM_LENGTH,
                lampY: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP + CONFIG.SIGNAL_POLE_HEIGHT / 2,
                labelX: n4PoleX - CONFIG.LABEL_SIGNAL_OFFSET,
                labelY: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP + CONFIG.SIGNAL_POLE_HEIGHT / 2 + CONFIG.LABEL_SIGNAL_Y_OFFSET,
                cycleHandler: () => cycleSignal('N4')
            });

            // T3 - between VC and VD (with hood)
            const t3PoleX = vc.end + 32;
            const t3LampX = t3PoleX - CONFIG.SIGNAL_HOOD_ARM_LENGTH - CONFIG.SIGNAL_POLE_HEIGHT * CONFIG.SIGNAL_HOOD_RADIUS_MULTIPLIER - CONFIG.SIGNAL_LAMP_RADIUS;
            drawSignal(svg, {
                name: 'T3',
                poleX: t3PoleX,
                poleYTop: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP,
                lampX: t3LampX,
                lampY: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP + CONFIG.SIGNAL_POLE_HEIGHT / 2,
                labelX: t3PoleX + CONFIG.LABEL_SIGNAL_OFFSET,
                labelY: CONFIG.SIGNAL_POLE_Y_OFFSET_TOP + CONFIG.SIGNAL_POLE_HEIGHT / 2 + CONFIG.LABEL_SIGNAL_Y_OFFSET,
                hasHood: true,
                hoodConfig: { direction: 'left' },
                cycleHandler: () => cycleSignalT3()
            });

            // T7 - between AD and AC
            const t7PoleX = ad.end + 32;
            drawSignal(svg, {
                name: 'T7',
                poleX: t7PoleX,
                poleYTop: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM,
                lampX: t7PoleX - CONFIG.SIGNAL_ARM_LENGTH,
                lampY: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM + CONFIG.SIGNAL_POLE_HEIGHT / 2,
                labelX: t7PoleX + CONFIG.LABEL_SIGNAL_OFFSET,
                labelY: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM + CONFIG.SIGNAL_POLE_HEIGHT / 2 + CONFIG.LABEL_SIGNAL_Y_OFFSET,
                cycleHandler: () => cycleSignal('T7')
            });

            // S6 - between AC and AB (hood only, no lamp)
            const s6PoleX = vb.end + CONFIG.GAP_LINE_WIDTH + (ab.start - (vb.end + CONFIG.GAP_LINE_WIDTH)) / 2;
            const s6LampY = lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM + CONFIG.SIGNAL_POLE_HEIGHT / 2 - CONFIG.SHUNT_SYMBOL_OFFSET;
            drawSignal(svg, {
                name: 'S6',
                poleX: s6PoleX,
                poleYTop: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM,
                lampX: s6PoleX,
                lampY: s6LampY,
                labelX: s6PoleX - CONFIG.LABEL_SIGNAL_OFFSET,
                labelY: s6LampY + CONFIG.LABEL_SIGNAL_Y_OFFSET,
                hasHood: true,
                hoodConfig: { direction: 'right' },
                cycleHandler: () => cycleSignalS6()
            });

            // T5 - between AB and AA (with hood)
            const t5PoleX = ab.rightEnd + 32;
            const t5LampX = t5PoleX - CONFIG.SIGNAL_HOOD_ARM_LENGTH - CONFIG.SIGNAL_POLE_HEIGHT * CONFIG.SIGNAL_HOOD_RADIUS_MULTIPLIER - CONFIG.SIGNAL_LAMP_RADIUS;
            drawSignal(svg, {
                name: 'T5',
                poleX: t5PoleX,
                poleYTop: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM,
                lampX: t5LampX,
                lampY: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM + CONFIG.SIGNAL_POLE_HEIGHT / 2,
                labelX: t5PoleX + CONFIG.LABEL_SIGNAL_OFFSET,
                labelY: lowerY + CONFIG.SIGNAL_POLE_Y_OFFSET_BOTTOM + CONFIG.SIGNAL_POLE_HEIGHT / 2 + CONFIG.LABEL_SIGNAL_Y_OFFSET,
                hasHood: true,
                hoodConfig: { direction: 'left' },
                cycleHandler: () => cycleSignalT5()
            });
        }

        /**
         * Draw shunt symbols
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawShuntSymbols(svg, layout) {
            const { upperY, lowerY, vb, vc, triangles } = layout;

            // S6 shunt symbol (above AC-AB vertical line)
            const s6SymbolX = vb.end + CONFIG.GAP_LINE_WIDTH;
            const s6SymbolY = lowerY - CONFIG.GAP_LINE_HEIGHT / 2 - CONFIG.SHUNT_SYMBOL_OFFSET;
            drawShuntSymbol(svg, s6SymbolX, s6SymbolY, 'S6', false, false);

            // T5 shunt symbol (below AB-Triangle vertical line)
            const t5SymbolX = triangles.vcVd.triangle1X + (CONFIG.TRIANGLE_OFFSET - CONFIG.TRIANGLE_SIZE);
            const t5SymbolY = lowerY + CONFIG.GAP_LINE_HEIGHT / 2 + CONFIG.SHUNT_SYMBOL_OFFSET;
            drawShuntSymbol(svg, t5SymbolX, t5SymbolY, 'T5', true, true);

            // T3 shunt symbol (below VC-VD left triangle)
            const t3SymbolX = triangles.vcVd.triangle1X - CONFIG.TRIANGLE_SIZE;
            const t3SymbolY = upperY + CONFIG.TRIANGLE_SIZE + CONFIG.SHUNT_SYMBOL_OFFSET;
            drawShuntSymbol(svg, t3SymbolX, t3SymbolY, 'T3', true, true);
        }

        /**
         * Draw platforms
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawPlatforms(svg, layout) {
            const { upperY, lowerY, va, vd } = layout;

            const platformTopY = upperY + CONFIG.PLATFORM_Y_OFFSET;
            const platformBottomY = lowerY - CONFIG.PLATFORM_Y_OFFSET;

            // Platform B (between VA and AD)
            const platformBX = va.start + va.width / 2 - CONFIG.PLATFORM_LABEL_OFFSET;
            drawPlatform(svg, platformBX, platformTopY, platformBottomY, 'Platform B');

            // Platform A (between VD and AA)
            const platformAX = vd.start + vd.width / 2 - CONFIG.PLATFORM_LABEL_OFFSET;
            drawPlatform(svg, platformAX, platformTopY, platformBottomY, 'Platform A');
        }

        /**
         * Draw diagonal track
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawDiagonal(svg, layout) {
            const { upperY, lowerY, vc, ab } = layout;

            // Calculate diagonal endpoints
            let diagX1 = vc.rightStart - CONFIG.DIAG_OFFSET;
            let diagY1 = upperY;
            let diagX2 = ab.leftEnd + CONFIG.DIAG_OFFSET;
            let diagY2 = lowerY;

            // Calculate diagonal vector
            const diagDx = diagX2 - diagX1;
            const diagDy = diagY2 - diagY1;
            const diagLength = Math.sqrt(diagDx * diagDx + diagDy * diagDy);
            const diagUx = diagDx / diagLength;
            const diagUy = diagDy / diagLength;

            // Adjust for switch states
            if (state.switches['11A'] === 'NORMAL') {
                diagX1 += diagUx * CONFIG.SWITCH_NORMAL_SHORTENING;
                diagY1 += diagUy * CONFIG.SWITCH_NORMAL_SHORTENING;
            }
            if (state.switches['11B'] === 'NORMAL') {
                diagX2 -= diagUx * CONFIG.SWITCH_NORMAL_SHORTENING;
                diagY2 -= diagUy * CONFIG.SWITCH_NORMAL_SHORTENING;
            }

            // Calculate midpoint with gap
            const diagMidX = (diagX1 + diagX2) / 2;
            const diagMidY = (diagY1 + diagY2) / 2;
            const diagSplit1X2 = diagMidX - diagUx * CONFIG.DIAG_GAP_DISTANCE;
            const diagSplit1Y2 = diagMidY - diagUy * CONFIG.DIAG_GAP_DISTANCE;
            const diagSplit2X1 = diagMidX + diagUx * CONFIG.DIAG_GAP_DISTANCE;
            const diagSplit2Y1 = diagMidY + diagUy * CONFIG.DIAG_GAP_DISTANCE;

            // Determine line caps
            const cap1 = (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'NORMAL') ? 'butt' :
                        (state.switches['11A'] === 'REVERSE' && state.switches['11B'] === 'NORMAL') ? 'round' : 'butt';
            const cap2 = (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'NORMAL') ? 'butt' :
                        (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'REVERSE') ? 'round' :
                        (state.switches['11A'] === 'REVERSE' && state.switches['11B'] === 'REVERSE') ? 'round' : 'butt';

            // Draw diagonal segments
            const line1 = createSVGElement('line');
            setAttributes(line1, {
                x1: diagX1, y1: diagY1,
                x2: diagSplit1X2, y2: diagSplit1Y2,
                stroke: getColor(state.tracks['DIAG']),
                'stroke-width': CONFIG.TRACK_WIDTH,
                'stroke-linecap': cap1
            });
            svg.appendChild(line1);

            const line2 = createSVGElement('line');
            setAttributes(line2, {
                x1: diagSplit2X1, y1: diagSplit2Y1,
                x2: diagX2, y2: diagY2,
                stroke: getColor(state.tracks['DIAG']),
                'stroke-width': CONFIG.TRACK_WIDTH,
                'stroke-linecap': cap2
            });
            svg.appendChild(line2);
        }

        /**
         * Draw switch overlays and indicators
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawSwitches(svg, layout) {
            const { upperY, lowerY, vc, ab } = layout;

            // 11A overlay
            if (state.switches['11A'] === 'NORMAL') {
                const line = createSVGElement('line');
                setAttributes(line, {
                    x1: vc.switch11A.start - CONFIG.SWITCH_OVERLAP,
                    y1: upperY,
                    x2: vc.switch11A.end + CONFIG.SWITCH_OVERLAP,
                    y2: upperY,
                    stroke: getColor(state.tracks['VC_LEFT']),
                    'stroke-width': CONFIG.TRACK_WIDTH,
                    'stroke-linecap': 'butt'
                });
                svg.appendChild(line);
            }

            // 11A broken indicator
            drawSwitchIndicator(svg, '11A', (vc.switch11A.start + vc.switch11A.end) / 2, upperY);

            // 11B overlay
            if (state.switches['11B'] === 'NORMAL') {
                const line = createSVGElement('line');
                setAttributes(line, {
                    x1: ab.switch11B.start - CONFIG.SWITCH_OVERLAP,
                    y1: lowerY,
                    x2: ab.switch11B.end + CONFIG.SWITCH_OVERLAP,
                    y2: lowerY,
                    stroke: getColor(state.tracks['AB_LEFT']),
                    'stroke-width': CONFIG.TRACK_WIDTH,
                    'stroke-linecap': 'butt'
                });
                svg.appendChild(line);
            }

            // 11B broken indicator
            drawSwitchIndicator(svg, '11B', (ab.switch11B.start + ab.switch11B.end) / 2, lowerY);
        }

        /**
         * Draw end labels (SELATAN / UTARA)
         * @param {SVGElement} svg - SVG container
         * @param {Object} layout - Track layout
         */
        function drawEndLabels(svg, layout) {
            const { upperY, lowerY, startX, aa } = layout;
            const middleY = (upperY + lowerY) / 2;

            drawLabel(svg, startX - CONFIG.LABEL_END_OFFSET, middleY, 'SELATAN');
            drawLabel(svg, aa.end + CONFIG.LABEL_END_OFFSET, middleY, 'UTARA');
        }

        /**
         * Main track drawing function - orchestrates all drawing
         */
        function drawTrack() {
            const svg = document.getElementById('trackSvg');
            svg.innerHTML = '';

            // Background
            const bg = createSVGElement('rect');
            setAttributes(bg, {
                width: CONFIG.SVG_WIDTH,
                height: CONFIG.SVG_HEIGHT,
                fill: COLORS.BLACK
            });
            svg.appendChild(bg);

            // Calculate layout
            const layout = calculateTrackLayout();

            // Draw all components in order
            drawUpperTrack(svg, layout);
            drawLowerTrack(svg, layout);
            drawGapLines(svg, layout);
            drawTriangles(svg, layout);
            drawDiagonal(svg, layout);
            drawSwitches(svg, layout);
            drawShuntSymbols(svg, layout);
            drawPlatforms(svg, layout);
            drawSignals(svg, layout);
            drawEndLabels(svg, layout);
        }

        // ════════════════════════════════════════════════════════════════
        // 7. STATE MODIFICATION FUNCTIONS
        // ════════════════════════════════════════════════════════════════

        /**
         * Toggle power state
         */
        function togglePower() {
            state.power = state.power === 'on' ? 'off' : 'on';
            updatePowerUI();
            render();
        }

        /**
         * Set mode (VDU/DOMINO)
         * @param {string} newMode - New mode ('vdu' or 'domino')
         */
        function setMode(newMode) {
            if (state.power === 'off') return;
            state.mode = newMode;
            updateModeUI();
            render();
        }

        /**
         * Cycle track state
         * @param {string} trackName - Track name
         */
        function cycleState(trackName) {
            if (state.power === 'off') return;

            const stateOrder = ['magenta', 'white', 'green', 'red'];
            const currentIndex = stateOrder.indexOf(state.tracks[trackName]);
            state.tracks[trackName] = stateOrder[(currentIndex + 1) % stateOrder.length];

            // Handle switch synchronization
            if (trackName === 'VC_LEFT' && state.switches['11A'] === 'NORMAL') {
                state.tracks['VC_RIGHT'] = state.tracks['VC_LEFT'];
                state.tracks['VC_11A'] = state.tracks['VC_LEFT'];
            }
            if (trackName === 'AB_LEFT' && state.switches['11B'] === 'NORMAL') {
                state.tracks['AB_RIGHT'] = state.tracks['AB_LEFT'];
                state.tracks['AB_11B'] = state.tracks['AB_LEFT'];
            }

            render();
        }

        /**
         * Cycle signal state
         * @param {string} signalName - Signal name
         */
        function cycleSignal(signalName) {
            if (state.power === 'off') return;

            const stateOrder = ['off', 'green', 'red', 'broken'];
            const currentIndex = stateOrder.indexOf(state.signals[signalName] || 'off');
            state.signals[signalName] = stateOrder[(currentIndex + 1) % stateOrder.length];

            render();
        }

        /**
         * Cycle T5 signal state
         */
        function cycleSignalT5() {
            cycleSignal('T5');
        }

        /**
         * Cycle T3 signal state
         */
        function cycleSignalT3() {
            cycleSignal('T3');
        }

        /**
         * Cycle S6 signal state
         */
        function cycleSignalS6() {
            cycleSignal('S6');
        }

        /**
         * Toggle switch position
         * @param {string} switchName - Switch name
         */
        function toggleSwitch(switchName) {
            if (state.power === 'off') return;
            state.switches[switchName] = state.switches[switchName] === 'NORMAL' ? 'REVERSE' : 'NORMAL';
            render();
        }

        /**
         * Toggle switch state (OK/broken)
         * @param {string} switchName - Switch name
         */
        function toggleSwitchState(switchName) {
            if (state.power === 'off') return;
            state.switchStates[switchName] = state.switchStates[switchName] === 'OK' ? 'broken' : 'OK';
            render();
        }

        /**
         * Toggle hood state
         * @param {string} hoodName - Hood name
         */
        function toggleHood(hoodName) {
            if (state.power === 'off') return;
            state.hoods[hoodName] = state.hoods[hoodName] === 'empty' ? 'filled' : 'empty';
            render();
        }

        /**
         * Update power UI
         */
        function updatePowerUI() {
            const powerBtn = document.getElementById('powerBtn');
            const statusDiv = document.getElementById('systemStatus');

            if (state.power === 'on') {
                powerBtn.textContent = 'ON';
                powerBtn.className = 'power-button on';
                statusDiv.textContent = `SYSTEM: READY (${state.mode.toUpperCase()})`;
                statusDiv.className = 'system-status';
            } else {
                powerBtn.textContent = 'OFF';
                powerBtn.className = 'power-button off';
                statusDiv.textContent = 'SYSTEM: OFFLINE';
                statusDiv.className = 'system-status off';
            }
        }

        /**
         * Update mode UI
         */
        function updateModeUI() {
            const vduBtn = document.getElementById('vduBtn');
            const dominoBtn = document.getElementById('dominoBtn');

            if (state.mode === 'vdu') {
                vduBtn.className = 'active';
                dominoBtn.className = 'inactive';
            } else {
                vduBtn.className = 'inactive';
                dominoBtn.className = 'active';
            }
            updatePowerUI();
        }

        // ════════════════════════════════════════════════════════════════
        // 8. CONTROL PANEL UI BUILDER
        // ════════════════════════════════════════════════════════════════

        /**
         * Create control button
         * @param {string} text - Button text
         * @param {boolean} active - Is active
         * @param {Function} onClick - Click handler
         * @returns {HTMLElement} Button element
         */
        function createControlButton(text, active, onClick) {
            const btn = document.createElement('button');
            btn.textContent = text;
            btn.className = active ? 'active' : '';
            btn.onclick = onClick;
            return btn;
        }

        /**
         * Create track control item
         * @param {string} name - Track name
         * @param {string} state - Current state
         * @param {Function} onClick - Click handler
         * @returns {HTMLElement} Track item element
         */
        function createTrackItem(name, state, onClick) {
            const div = document.createElement('div');
            div.className = 'track-item';

            const label = document.createElement('div');
            label.className = 'track-name';
            label.textContent = name.replace(/_/g, ' ');

            const btn = document.createElement('button');
            btn.className = `track-btn ${state}`;
            btn.textContent = state.toUpperCase();
            btn.onclick = onClick;

            div.appendChild(label);
            div.appendChild(btn);
            return div;
        }

        /**
         * Create switch control item
         * @param {string} name - Switch name
         * @returns {HTMLElement} Switch item element
         */
        function createSwitchItem(name) {
            const div = document.createElement('div');
            div.className = 'track-item';

            const label = document.createElement('div');
            label.className = 'track-name';
            label.textContent = name;

            // Position buttons
            const btnGroup = document.createElement('div');
            btnGroup.className = 'btn-group';
            btnGroup.appendChild(createControlButton('NORMAL', state.switches[name] === 'NORMAL', () => toggleSwitch(name)));
            btnGroup.appendChild(createControlButton('REVERSE', state.switches[name] === 'REVERSE', () => toggleSwitch(name)));

            // State buttons
            const stateGroup = document.createElement('div');
            stateGroup.className = 'btn-group';
            stateGroup.appendChild(createControlButton('OK', state.switchStates[name] === 'OK', () => toggleSwitchState(name)));
            stateGroup.appendChild(createControlButton('BROKEN', state.switchStates[name] === 'broken', () => toggleSwitchState(name)));

            div.appendChild(label);
            div.appendChild(btnGroup);
            div.appendChild(stateGroup);
            return div;
        }

        /**
         * Create hood control item
         * @param {string} name - Hood name
         * @returns {HTMLElement} Hood item element
         */
        function createHoodItem(name) {
            const div = document.createElement('div');
            div.className = 'track-item';

            const label = document.createElement('div');
            label.className = 'track-name';
            label.textContent = `${name} Hood`;

            const btnGroup = document.createElement('div');
            btnGroup.className = 'btn-group';
            btnGroup.appendChild(createControlButton('EMPTY', state.hoods[name] === 'empty', () => { if (state.hoods[name] !== 'empty') toggleHood(name); }));
            btnGroup.appendChild(createControlButton('FILLED', state.hoods[name] === 'filled', () => { if (state.hoods[name] !== 'filled') toggleHood(name); }));

            div.appendChild(label);
            div.appendChild(btnGroup);
            return div;
        }

        /**
         * Create section title
         * @param {string} title - Title text
         * @returns {HTMLElement} Title element
         */
        function createSectionTitle(title) {
            const div = document.createElement('div');
            div.className = 'section-title';
            div.textContent = title;
            return div;
        }

        /**
         * Update control panel
         */
        function updateControls() {
            const container = document.getElementById('trackControls');
            container.innerHTML = '';

            // Switches
            container.appendChild(createSectionTitle('POINT MACHINES'));
            container.appendChild(createSwitchItem('11A'));
            container.appendChild(createSwitchItem('11B'));

            // Signals
            container.appendChild(createSectionTitle('SIGNALS'));
            ['N4', 'T7', 'S6', 'T5', 'T3'].forEach(signalName => {
                const cycleHandler = signalName === 'N4' || signalName === 'T7' ? () => cycleSignal(signalName) :
                                    signalName === 'S6' ? cycleSignalS6 :
                                    signalName === 'T5' ? cycleSignalT5 : cycleSignalT3;
                container.appendChild(createTrackItem(signalName, state.signals[signalName], cycleHandler));
            });

            // Hoods
            container.appendChild(createSectionTitle('HOODS'));
            ['T5', 'S6', 'T3'].forEach(hoodName => {
                container.appendChild(createHoodItem(hoodName));
            });

            // Track sections
            container.appendChild(createSectionTitle('TRACK SECTIONS'));
            ['VA', 'VB', 'VC_LEFT', 'VC_11A', 'VC_RIGHT', 'VD'].forEach(trackName => {
                if (trackName === 'VC_11A' && state.switches['11A'] === 'NORMAL') return;
                container.appendChild(createTrackItem(trackName, state.tracks[trackName], () => cycleState(trackName)));
            });

            ['AD', 'AC', 'AB_LEFT', 'AB_11B', 'AB_RIGHT', 'AA'].forEach(trackName => {
                if (trackName === 'AB_11B' && state.switches['11B'] === 'NORMAL') return;
                container.appendChild(createTrackItem(trackName, state.tracks[trackName], () => cycleState(trackName)));
            });

            container.appendChild(createTrackItem('DIAG', state.tracks['DIAG'], () => cycleState('DIAG')));
        }

        // ════════════════════════════════════════════════════════════════
        // 9. MAIN RENDER & INITIALIZATION
        // ════════════════════════════════════════════════════════════════

        /**
         * Main render function
         */
        function render() {
            drawTrack();
            updateControls();

            const controlsDiv = document.querySelector('.controls');
            if (state.power === 'off') {
                controlsDiv.classList.add('disabled');
            } else {
                controlsDiv.classList.remove('disabled');
            }
        }

        /**
         * Initialize event listeners
         */
        function initializeEventListeners() {
            document.getElementById('powerBtn').addEventListener('click', togglePower);
            document.getElementById('vduBtn').addEventListener('click', () => setMode('vdu'));
            document.getElementById('dominoBtn').addEventListener('click', () => setMode('domino'));
        }

        // Initialize application
        render();
        initializeEventListeners();
    </script>
</body>
</html>
