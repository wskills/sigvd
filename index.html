<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Railway Track Visualization</title>
    <style>
        body { margin: 0; padding: 20px; background-color: #000000; font-family: Arial, sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; margin-bottom: 20px; color: #ffffff; }
        .svg-container { background-color: #000000; border: 2px solid #ffffff; padding: 20px; display: flex; justify-content: center; }
        svg { background-color: #000000; border: 1px solid #ffffff; }
        .controls { margin-top: 30px; padding: 20px; background-color: #000000; border: 2px solid #ffffff; color: #ffffff; }
        .controls.disabled { opacity: 0.4; pointer-events: none; }
        .track-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; }
        .track-item { display: flex; flex-direction: column; gap: 8px; padding: 10px; border: 1px solid #ffffff; background-color: #1a1a1a; }
        .track-name { font-weight: bold; font-size: 14px; text-align: center; color: #ffffff; }
        .track-btn { padding: 8px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; transition: all 0.2s; }
        .track-btn:hover { opacity: 0.8; }
        .track-btn.off { background-color: transparent; color: #ffffff; }
        .track-btn.white { background-color: #ffffff; color: #000; }
        .track-btn.green { background-color: #00ff00; color: #000; }
        .track-btn.red { background-color: #ff0000; color: #fff; }
        .track-btn.yellow { background-color: #ffff00; color: #000; }
        .track-btn.broken { background-color: transparent; color: #ffff00; border-color: #ffff00; }
        .track-btn.magenta { background-color: #ff00ff; color: #fff; }
        .btn-group { display: flex; gap: 5px; }
        .btn-group button { flex: 1; padding: 6px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; background-color: #333; color: #ffffff; }
        .btn-group button.active { background-color: #0066cc; color: #fff; }
        .section-title { grid-column: 1 / -1; font-weight: bold; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 2px solid #ffffff; color: #ffffff; }
        @keyframes flash1Hz { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }
        .broken-ring { animation: flash1Hz 1s infinite; }
        .top-controls { display: flex; gap: 20px; margin-bottom: 30px; align-items: center; justify-content: center; }
        .control-group { display: flex; gap: 15px; align-items: center; }
        .control-group label { font-weight: bold; color: #ffffff; font-size: 16px; }
        .control-switch { display: flex; gap: 10px; }
        .control-switch button { padding: 10px 20px; border: 2px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 4px; transition: all 0.2s; min-width: 80px; }
        .control-switch button.inactive { background-color: #333; color: #ffffff; }
        .control-switch button.active { background-color: #0066cc; color: #ffffff; }
        .power-button { padding: 12px 30px; border: 3px solid #ffffff; font-weight: bold; cursor: pointer; border-radius: 6px; font-size: 16px; transition: all 0.3s; min-width: 100px; }
        .power-button.on { background-color: #00ff00; color: #000; }
        .power-button.off { background-color: #ff0000; color: #fff; }
        .power-button:hover { transform: scale(1.05); }
        .system-status { color: #00ff00; font-weight: bold; font-size: 14px; }
        .system-status.off { color: #ff0000; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Railway Track Visualization - Domino Panel</h1>
        <div class="top-controls">
            <div class="control-group">
                <label>POWER:</label>
                <button class="power-button on" id="powerBtn">ON</button>
            </div>
            <div class="control-group">
                <label>MODE:</label>
                <div class="control-switch">
                    <button class="active" id="vduBtn">VDU</button>
                    <button class="inactive" id="dominoBtn">DOMINO</button>
                </div>
            </div>
            <div id="systemStatus" class="system-status">SYSTEM: READY</div>
        </div>
        <div class="svg-container">
            <svg id="trackSvg" width="1440" height="350" viewBox="0 0 1440 350"></svg>
        </div>
        <div id="routeLog" style="background-color: #000000; border: 2px solid #00ff00; padding: 15px; margin-top: 20px; max-height: 150px; overflow-y: auto; font-family: monospace; color: #00ff00; font-size: 12px; white-space: pre-wrap; word-wrap: break-word;">
            <div style="font-weight: bold; margin-bottom: 10px;">ROUTE LOG:</div>
        </div>
        <div class="controls">
            <h2>Controls</h2>
            <div class="track-controls" id="trackControls"></div>
        </div>
    </div>

    <script>
        // ╔══════════════════════════════════════════════════════════════╗
        // ║        RAILWAY TRACK VISUALIZATION - SIMPLIFIED             ║
        // ║              Data-Driven, Maintainable Code                  ║
        // ╚══════════════════════════════════════════════════════════════╝

        // ════════════════════════════════════════════════════════════════
        // 1. CONFIGURATION - All dimensions and colors
        // ════════════════════════════════════════════════════════════════

        const CONFIG = {
            svg: { width: 1440, height: 350 },
            track: { width: 10, standard: 193, extended: 331, shortened: 161, upperY: 100, lowerY: 250 },
            triangle: { size: 12, gap: 8, offset: 24 },
            signal: { poleWidth: 3, poleHeight: 20, lampRadius: 10, armLength: 20, hoodArmLength: 8,
                     hoodRadiusMultiplier: 1.3, brokenRingOffset: 4, poleYOffsetTop: 20, poleYOffsetBottom: 40 },
            hood: { diagonalGapApex: 5, diagonalGapArc: 7, fillColor: '#0066ff' },
            shunt: { symbolSize: 10, symbolOffset: 10, diagonalLength: 0.8 },
            platform: { width: 100, yOffset: 20, labelOffset: 50 },
            switch: { sectionWidth: 40, overlap: 10, normalShortening: 50, indicatorRadius: 8 },
            diag: { gapDistance: 4, offset: 2 },
            gap: { width: 8, height: 18 },
            label: { yOffsetUpper: 30, yOffsetLower: 30, signalOffset: 25, signalYOffset: 6,
                    bgWidth: 30, bgHeight: 18, bgRadius: 2, endOffset: 50 }
        };

        const COLORS = {
            off: '#ff00ff', white: '#ffffff', green: '#00ff00',
            red: '#ff0000', yellow: '#ffff00', black: '#000000'
        };

        // ════════════════════════════════════════════════════════════════
        // 2. DATA MODELS - Define all entities as data
        // ════════════════════════════════════════════════════════════════

        const TRACKS = [
            { name: 'VA', line: 'upper' }, { name: 'VB', line: 'upper' }, { name: 'VC_LEFT', line: 'upper' },
            { name: 'VC_11A', line: 'upper' }, { name: 'VC_RIGHT', line: 'upper' }, { name: 'VD', line: 'upper' },
            { name: 'AD', line: 'lower' }, { name: 'AC', line: 'lower' }, { name: 'AB_LEFT', line: 'lower' },
            { name: 'AB_11B', line: 'lower' }, { name: 'AB_RIGHT', line: 'lower' }, { name: 'AA', line: 'lower' },
            { name: 'DIAG', line: 'diagonal' }
        ];

        const SIGNALS = [
            { name: 'N4', type: 'main', hasHood: false, track: 'upper', position: 'between-VA-VB', labelSide: 'left' },
            { name: 'T7', type: 'main', hasHood: false, track: 'lower', position: 'after-AD', labelSide: 'right' },
            { name: 'S6', type: 'shunt', hasHood: true, hoodDirection: 'right', track: 'lower', position: 'between-AC-AB', labelSide: 'left' },
            { name: 'T5', type: 'shunt', hasHood: true, hoodDirection: 'left', track: 'lower', position: 'after-AB', labelSide: 'right' },
            { name: 'T3', type: 'shunt', hasHood: true, hoodDirection: 'left', track: 'upper', position: 'after-VC', labelSide: 'right' }
        ];

        const TRIANGLES = [
            { signal: 'N4', direction: 'Utara Direction', x: 'vaVb1', y: 'upper', orientation: 'right' },
            { signal: 'N4', direction: 'Selatan Direction', x: 'vaVb2', y: 'upper', orientation: 'left' },
            { signal: 'T3', direction: 'Utara Direction', x: 'vcVd1', y: 'upper', orientation: 'right' },
            { signal: 'T3', direction: 'Selatan Direction', x: 'vcVd2', y: 'upper', orientation: 'left' },
            { signal: 'T7', direction: 'Selatan Direction', x: 'adAc', y: 'lower', orientation: 'left' },
            { signal: 'T5', direction: 'Selatan Direction', x: 'vcVd2', y: 'lower', orientation: 'left' }
        ];

        const SHUNT_SYMBOLS = [
            { signal: 'S6', x: 'acAbGap', y: 'aboveGap', flipH: false, flipV: false },
            { signal: 'T5', x: 'abTriangleGap', y: 'belowGap', flipH: true, flipV: true },
            { signal: 'T3', x: 'leftOfVcVd', y: 'belowTriangle', flipH: true, flipV: true }
        ];

        const CONTROL_SECTIONS = [
            { title: 'POINT MACHINES', type: 'switch', items: ['11A', '11B'] },
            { title: 'SIGNALS', type: 'signal', items: ['N4', 'T7', 'S6', 'T5', 'T3'] },
            { title: 'HOODS', type: 'hood', items: ['T5', 'S6', 'T3'] },
            { title: 'TRACK SECTIONS', type: 'track', items: ['VA', 'VB', 'VC_LEFT', 'VC_11A', 'VC_RIGHT', 'VD',
                                                               'AD', 'AC', 'AB_LEFT', 'AB_11B', 'AB_RIGHT', 'AA', 'DIAG'] }
        ];

        const VALID_ROUTES = {
            'N4-Utara Direction': ['T3-Utara Direction'],
            'T3-Selatan Direction': ['N4-Selatan Direction', 'T7-Selatan Direction'],
            'T5-Selatan Direction': ['T7-Selatan Direction']
        };

        const INVALID_ROUTE_MESSAGES = {
            'N4-Selatan Direction|T3-Selatan Direction': 'wrong sequence',
            'T3-Utara Direction|N4-Utara Direction': 'wrong sequence',
            'T5-Utara Direction|T7-Utara Direction': 'no Utara triangle',
            'T7-Selatan Direction|T5-Selatan Direction': 'wrong sequence',
            'T7-Utara Direction|T5-Utara Direction': 'no Utara triangle',
            'T3-Selatan Direction|T5-Selatan Direction': 'impossible',
            'T3-Utara Direction|T7-Utara Direction': 'no Utara triangle',
            'T5-Selatan Direction|T3-Selatan Direction': 'impossible',
            'T7-Selatan Direction|T3-Selatan Direction': 'wrong sequence'
        };

        const VALID_SHUNT_CONNECTIONS = {
            'S6': ['T5', 'T3'], 'T5': ['S6'], 'T3': ['S6']
        };

        // ════════════════════════════════════════════════════════════════
        // 3. STATE MANAGEMENT
        // ════════════════════════════════════════════════════════════════

        const state = {
            power: 'on',
            mode: 'vdu',
            tracks: Object.fromEntries(TRACKS.map(t => [t.name, 'white'])),
            signals: Object.fromEntries(SIGNALS.map(s => [s.name, 'off'])),
            hoods: { T5: 'empty', T3: 'empty', S6: 'empty' },
            switches: { '11A': 'NORMAL', '11B': 'NORMAL' },
            switchStates: { '11A': 'OK', '11B': 'OK' }
        };

        const routeState = { selectedTriangle: null, routeLog: [] };

        // ════════════════════════════════════════════════════════════════
        // 4. HELPER FUNCTIONS - Consolidated utilities
        // ════════════════════════════════════════════════════════════════

        const svg = () => document.getElementById('trackSvg');
        const createElement = (type, attrs) => {
            const el = document.createElementNS('http://www.w3.org/2000/svg', type);
            Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
            return el;
        };

        const getColor = (trackState) => {
            if (state.power === 'off') return COLORS.off;
            return COLORS[trackState] || COLORS.off;
        };

        const getSignalColor = (signalState) => {
            if (state.power === 'off') return 'none';
            return COLORS[signalState] || 'none';
        };

        const defaultColor = () => state.power === 'off' ? COLORS.off : COLORS.white;

        // ════════════════════════════════════════════════════════════════
        // 5. ROUTE VALIDATION
        // ════════════════════════════════════════════════════════════════

        const isValidRoute = (from, fromDir, to, toDir) =>
            VALID_ROUTES[`${from}-${fromDir}`]?.includes(`${to}-${toDir}`) || false;

        const isValidShuntRoute = (from, to) =>
            from !== to && (VALID_SHUNT_CONNECTIONS[from]?.includes(to) || false);

        const getInvalidRouteMessage = (from, fromDir, to, toDir) =>
            INVALID_ROUTE_MESSAGES[`${from}-${fromDir}|${to}-${toDir}`] || 'invalid route';

        const logRoute = (from, fromDir, to, toDir, isValid = true, errorMsg = '') => {
            const text = isValid
                ? `Route set: ${from} ${fromDir} --> ${to} ${toDir}`
                : `Invalid route: ${from} ${fromDir} --> ${to} ${toDir} (${errorMsg})`;

            routeState.routeLog.push(text);
            console.log(text);

            const log = document.getElementById('routeLog');
            if (log) {
                const entry = document.createElement('div');
                entry.textContent = text;
                entry.style.color = isValid ? COLORS.green : COLORS.red;
                entry.style.fontFamily = 'monospace';
                entry.style.padding = '5px';
                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }
        };

        const handleTriangleClick = (signalName, direction) => {
            if (state.power === 'off') return console.log('Cannot set routes - system power is OFF');

            if (!routeState.selectedTriangle) {
                routeState.selectedTriangle = { signalName, direction, isShunt: false };
                console.log(`Route origin selected: ${signalName} ${direction}`);
            } else {
                const from = routeState.selectedTriangle;
                if (from.isShunt) {
                    logRoute(from.signalName, from.direction, signalName, direction, false,
                            'Cannot connect shunt route to main route');
                } else if (isValidRoute(from.signalName, from.direction, signalName, direction)) {
                    logRoute(from.signalName, from.direction, signalName, direction, true);
                } else {
                    logRoute(from.signalName, from.direction, signalName, direction, false,
                            getInvalidRouteMessage(from.signalName, from.direction, signalName, direction));
                }
                routeState.selectedTriangle = null;
            }
        };

        const handleShuntRouteClick = (signalName, routeType) => {
            if (state.power === 'off') return console.log('Cannot set shunt routes - system power is OFF');

            if (!routeState.selectedTriangle) {
                routeState.selectedTriangle = { signalName, direction: routeType, isShunt: true };
                console.log(`Shunt route origin selected: ${signalName} ${routeType}`);
            } else {
                const from = routeState.selectedTriangle;
                if (from.isShunt && routeType === 'Shunt') {
                    const valid = isValidShuntRoute(from.signalName, signalName);
                    logRoute(from.signalName, from.direction, signalName, routeType, valid,
                            valid ? '' : `Shunt route ${from.signalName} cannot connect to ${signalName}`);
                } else if (!from.isShunt) {
                    logRoute(from.signalName, from.direction, signalName, routeType, false,
                            'Cannot connect main route to shunt route');
                } else {
                    logRoute(from.signalName, from.direction, signalName, routeType, false,
                            'Shunt routes can only connect to other shunt routes');
                }
                routeState.selectedTriangle = null;
            }
        };

        // ════════════════════════════════════════════════════════════════
        // 6. LAYOUT CALCULATIONS
        // ════════════════════════════════════════════════════════════════

        const calculateLayout = () => {
            const { upperY, lowerY, standard, extended, shortened } = CONFIG.track;
            const { offset, gap, size } = CONFIG.triangle;

            const totalWidth = standard + 40 + standard + 8 + (extended + 40) + 40 + standard;
            const startX = (CONFIG.svg.width - totalWidth) / 2;

            // Upper track
            const va = { start: startX, end: startX + shortened };
            const vaVb1X = va.end + size;
            const vaVb2X = va.end + offset + gap + size;
            const vb = { start: va.end + offset + gap + offset, end: 0 };
            vb.end = vb.start + standard;

            const vc = { start: vb.end + gap };
            vc.switch11A = { start: vc.start + extended * 0.75, end: vc.start + extended * 0.75 + CONFIG.switch.sectionWidth };
            vc.leftEnd = vc.switch11A.start + CONFIG.switch.overlap;
            vc.rightStart = vc.switch11A.end - CONFIG.switch.overlap;
            vc.rightEnd = vc.start + extended + CONFIG.switch.sectionWidth;
            vc.end = vc.rightEnd;

            const vcVd1X = vc.end + size;
            const vcVd2X = vc.end + offset + gap + size;
            const vd = { start: vcVd2X + size, end: 0 };
            vd.end = vd.start + shortened;

            // Lower track
            const ad = { start: startX, end: startX + standard };
            const ac = { start: ad.end + offset, end: vb.end };

            const ab = { start: vb.end + gap };
            const vcRightSize = vc.rightEnd - vc.rightStart;
            ab.leftEnd = ab.start + vcRightSize + 1;
            ab.switch11B = { start: ab.leftEnd - CONFIG.switch.overlap, end: ab.leftEnd - CONFIG.switch.overlap + CONFIG.switch.sectionWidth };
            ab.rightStart = ab.switch11B.end - CONFIG.switch.overlap;
            ab.rightEnd = ab.start + extended + CONFIG.switch.sectionWidth;
            ab.triangleGapX = vc.end + offset;
            ab.end = ab.triangleGapX;

            const aa = { start: vcVd2X + size, end: 0 };
            aa.end = aa.start + shortened;

            return {
                upperY, lowerY, startX,
                va, vb, vc, vd, ad, ac, ab, aa,
                vaVb1X, vaVb2X, vcVd1X, vcVd2X,
                middleY: (upperY + lowerY) / 2
            };
        };

        // ════════════════════════════════════════════════════════════════
        // 7. DRAWING PRIMITIVES
        // ════════════════════════════════════════════════════════════════

        const drawLine = (x1, y1, x2, y2, attrs = {}) =>
            svg().appendChild(createElement('line', { x1, y1, x2, y2, ...attrs }));

        const drawRect = (x, y, width, height, attrs = {}) =>
            svg().appendChild(createElement('rect', { x, y, width, height, ...attrs }));

        const drawCircle = (cx, cy, r, attrs = {}) =>
            svg().appendChild(createElement('circle', { cx, cy, r, ...attrs }));

        const drawPath = (d, attrs = {}) =>
            svg().appendChild(createElement('path', { d, ...attrs }));

        const drawPolygon = (points, attrs = {}) =>
            svg().appendChild(createElement('polygon', { points, ...attrs }));

        const drawText = (x, y, text, attrs = {}) => {
            const el = createElement('text', { x, y, 'text-anchor': 'middle', 'font-size': '14',
                                              'font-weight': 'bold', fill: defaultColor(), ...attrs });
            el.textContent = text;
            svg().appendChild(el);
        };

        // ════════════════════════════════════════════════════════════════
        // 8. RENDERING COMPONENTS
        // ════════════════════════════════════════════════════════════════

        const drawTrackSection = (x1, x2, y, trackName) => {
            drawLine(x1, y, x2, y, {
                stroke: getColor(state.tracks[trackName]),
                'stroke-width': CONFIG.track.width,
                'stroke-linecap': 'butt'
            });
        };

        const drawTriangle = (x, y, orientation, onClick) => {
            const s = CONFIG.triangle.size;
            const points = orientation === 'right'
                ? `${x-s},${y-s} ${x-s},${y+s} ${x+s},${y}`
                : `${x+s},${y-s} ${x+s},${y+s} ${x-s},${y}`;

            const triangle = drawPolygon(points, {
                fill: state.power === 'off' ? COLORS.off : COLORS.white,
                stroke: defaultColor(),
                'stroke-width': '2',
                cursor: 'pointer'
            });
            triangle.onclick = onClick;
            return triangle;
        };

        const drawSignalWithHood = (name, lampX, lampY, poleX, direction, cycleHandler) => {
            const radiusX = CONFIG.signal.poleHeight * CONFIG.signal.hoodRadiusMultiplier;
            const radiusY = CONFIG.signal.poleHeight;
            const lampR = CONFIG.signal.lampRadius;

            let hoodCenterX, hoodCenterY, hoodPath, diagStartX, diagStartY, diagEndX, diagEndY;

            if (direction === 'left') {
                hoodCenterX = lampX + lampR + radiusX;
                hoodCenterY = lampY - lampR;
                hoodPath = `M ${hoodCenterX},${hoodCenterY} L ${hoodCenterX-radiusX},${hoodCenterY} A ${radiusX},${radiusY} 0 0,0 ${hoodCenterX},${hoodCenterY+radiusY} Z`;
                diagStartX = hoodCenterX - CONFIG.hood.diagonalGapApex;
                diagStartY = hoodCenterY + CONFIG.hood.diagonalGapApex;
                const dist = Math.min(radiusX, radiusY) - CONFIG.hood.diagonalGapApex - CONFIG.hood.diagonalGapArc;
                diagEndX = diagStartX - dist;
                diagEndY = diagStartY + dist;
            } else {
                hoodCenterX = poleX + CONFIG.signal.hoodArmLength;
                hoodCenterY = lampY - lampR;
                hoodPath = `M ${hoodCenterX},${hoodCenterY+radiusY} L ${hoodCenterX+radiusX},${hoodCenterY+radiusY} A ${radiusX},${radiusY} 0 0,0 ${hoodCenterX},${hoodCenterY} Z`;
                diagStartX = hoodCenterX + CONFIG.hood.diagonalGapApex;
                diagStartY = hoodCenterY + radiusY - CONFIG.hood.diagonalGapApex;
                const dist = Math.min(radiusX, radiusY) - CONFIG.hood.diagonalGapApex - CONFIG.hood.diagonalGapArc;
                diagEndX = diagStartX + dist;
                diagEndY = diagStartY - dist;
            }

            // Lamp (if not S6)
            if (lampX !== poleX) {
                const lamp = drawCircle(lampX, lampY, lampR, {
                    fill: state.signals[name] === 'broken' ? 'none' : getSignalColor(state.signals[name]),
                    stroke: defaultColor(),
                    'stroke-width': '2',
                    cursor: 'pointer'
                });
                lamp.onclick = cycleHandler;

                if (state.signals[name] === 'broken' && state.power === 'on') {
                    const ring = drawCircle(lampX, lampY, lampR + CONFIG.signal.brokenRingOffset, {
                        fill: 'none', stroke: COLORS.yellow, 'stroke-width': '2',
                        cursor: 'pointer', class: 'broken-ring'
                    });
                    ring.onclick = cycleHandler;
                }
            }

            // Hood
            const hood = drawPath(hoodPath, {
                fill: state.hoods[name] === 'filled' ? CONFIG.hood.fillColor : 'none',
                stroke: defaultColor(),
                'stroke-width': '2',
                'stroke-linejoin': 'miter',
                cursor: 'pointer'
            });
            hood.onclick = () => toggleHood(name);

            // Diagonal when filled
            if (state.hoods[name] === 'filled') {
                drawLine(diagStartX, diagStartY, diagEndX, diagEndY, {
                    stroke: defaultColor(), 'stroke-width': '2'
                });
            }

            // Arm
            drawLine(poleX, lampY, hoodCenterX, lampY, {
                stroke: defaultColor(), 'stroke-width': '2'
            });
        };

        const drawSignal = (signal, layout) => {
            const { name, hasHood, hoodDirection, track, position, labelSide } = signal;
            const y = track === 'upper' ? layout.upperY : layout.lowerY;
            const yOffset = track === 'upper' ? CONFIG.signal.poleYOffsetTop : CONFIG.signal.poleYOffsetBottom;

            let poleX, lampX, lampY, labelX, labelY;

            // Calculate positions based on signal position
            if (position === 'between-VA-VB') {
                poleX = layout.va.end + (layout.vb.start - layout.va.end) / 2;
                lampX = poleX + CONFIG.signal.armLength;
            } else if (position === 'after-AD') {
                poleX = layout.ad.end + 32;
                lampX = poleX - CONFIG.signal.armLength;
            } else if (position === 'between-AC-AB') {
                poleX = layout.vb.end + CONFIG.gap.width + (layout.ab.start - (layout.vb.end + CONFIG.gap.width)) / 2;
                lampX = poleX;
                lampY = y + yOffset + CONFIG.signal.poleHeight / 2 - CONFIG.shunt.symbolOffset;
            } else if (position === 'after-AB') {
                poleX = layout.ab.rightEnd + 32;
                const radiusX = CONFIG.signal.poleHeight * CONFIG.signal.hoodRadiusMultiplier;
                lampX = poleX - CONFIG.signal.hoodArmLength - radiusX - CONFIG.signal.lampRadius;
            } else if (position === 'after-VC') {
                poleX = layout.vc.end + 32;
                const radiusX = CONFIG.signal.poleHeight * CONFIG.signal.hoodRadiusMultiplier;
                lampX = poleX - CONFIG.signal.hoodArmLength - radiusX - CONFIG.signal.lampRadius;
            }

            if (!lampY) lampY = yOffset + CONFIG.signal.poleHeight / 2;
            labelX = poleX + (labelSide === 'right' ? CONFIG.label.signalOffset : -CONFIG.label.signalOffset);
            labelY = (position === 'between-AC-AB' ? lampY : yOffset + CONFIG.signal.poleHeight / 2) + CONFIG.label.signalYOffset;

            // Pole
            drawLine(poleX, yOffset, poleX, yOffset + CONFIG.signal.poleHeight, {
                stroke: defaultColor(), 'stroke-width': CONFIG.signal.poleWidth
            });

            // Lamp or Hood
            if (hasHood) {
                drawSignalWithHood(name, lampX, lampY, poleX, hoodDirection, () => cycleSignal(name));
            } else {
                const armEndX = lampX > poleX ? lampX - CONFIG.signal.lampRadius : lampX + CONFIG.signal.lampRadius;
                drawLine(poleX, lampY, armEndX, lampY, { stroke: defaultColor(), 'stroke-width': '2' });

                const lamp = drawCircle(lampX, lampY, CONFIG.signal.lampRadius, {
                    fill: state.signals[name] === 'broken' ? 'none' : getSignalColor(state.signals[name]),
                    stroke: defaultColor(),
                    'stroke-width': '2',
                    cursor: 'pointer'
                });
                lamp.onclick = () => cycleSignal(name);

                if (state.signals[name] === 'broken' && state.power === 'on') {
                    const ring = drawCircle(lampX, lampY, CONFIG.signal.lampRadius + CONFIG.signal.brokenRingOffset, {
                        fill: 'none', stroke: COLORS.yellow, 'stroke-width': '2',
                        cursor: 'pointer', class: 'broken-ring'
                    });
                    ring.onclick = () => cycleSignal(name);
                }
            }

            // Label with background
            drawRect(labelX - CONFIG.label.bgWidth/2, labelY - CONFIG.label.bgHeight/2 - CONFIG.label.signalYOffset,
                    CONFIG.label.bgWidth, CONFIG.label.bgHeight, {
                fill: state.power === 'on' ? COLORS.red : 'none',
                rx: CONFIG.label.bgRadius
            });
            drawText(labelX, labelY, name);
        };

        const drawShuntSymbol = (symbol, layout) => {
            const { signal, x: xKey, y: yKey, flipH, flipV } = symbol;
            const size = CONFIG.shunt.symbolSize;
            const hDir = flipH ? -1 : 1;
            const vDir = flipV ? 1 : -1;

            let x, y;
            if (xKey === 'acAbGap') {
                x = layout.vb.end + CONFIG.gap.width;
                y = layout.lowerY - CONFIG.gap.height/2 - CONFIG.shunt.symbolOffset;
            } else if (xKey === 'abTriangleGap') {
                x = layout.vcVd1X + (CONFIG.triangle.offset - CONFIG.triangle.size);
                y = layout.lowerY + CONFIG.gap.height/2 + CONFIG.shunt.symbolOffset;
            } else if (xKey === 'leftOfVcVd') {
                x = layout.vcVd1X - CONFIG.triangle.size;
                y = layout.upperY + CONFIG.triangle.size + CONFIG.shunt.symbolOffset;
            }

            const drawSymLine = (x1, y1, x2, y2) => {
                const line = drawLine(x1, y1, x2, y2, {
                    stroke: defaultColor(), 'stroke-width': '2',
                    'stroke-linecap': 'round', cursor: 'pointer'
                });
                line.onclick = () => handleShuntRouteClick(signal, 'Shunt');
                return line;
            };

            drawSymLine(x, y, x + size * hDir, y);
            drawSymLine(x + size * hDir, y, x + size * hDir / 5, y + size * CONFIG.shunt.diagonalLength * vDir);
        };

        // ════════════════════════════════════════════════════════════════
        // 9. MAIN RENDERING
        // ════════════════════════════════════════════════════════════════

        const drawTrack = () => {
            svg().innerHTML = '';
            drawRect(0, 0, CONFIG.svg.width, CONFIG.svg.height, { fill: COLORS.black });

            const layout = calculateLayout();

            // Upper tracks
            drawTrackSection(layout.va.start, layout.va.end, layout.upperY, 'VA');
            drawText(layout.va.start + (layout.va.end - layout.va.start)/2, layout.upperY - CONFIG.label.yOffsetUpper, 'VA');

            drawTrackSection(layout.vb.start, layout.vb.end, layout.upperY, 'VB');
            drawText(layout.vb.start + (layout.vb.end - layout.vb.start)/2, layout.upperY - CONFIG.label.yOffsetUpper, 'VB');

            // VC with switch logic
            if (state.switches['11A'] === 'NORMAL') {
                drawTrackSection(layout.vc.start, layout.vc.rightEnd, layout.upperY, 'VC_LEFT');
            } else {
                drawTrackSection(layout.vc.start, layout.vc.leftEnd, layout.upperY, 'VC_LEFT');
                drawTrackSection(layout.vc.rightStart, layout.vc.rightEnd, layout.upperY, 'VC_RIGHT');
            }
            drawText(layout.vc.start + 60, layout.upperY - CONFIG.label.yOffsetUpper, 'VC');
            drawText(layout.vc.switch11A.start + 20, layout.upperY - CONFIG.label.yOffsetUpper, '11A');

            drawTrackSection(layout.vd.start, layout.vd.end, layout.upperY, 'VD');
            drawText(layout.vd.start + (layout.vd.end - layout.vd.start)/2, layout.upperY - CONFIG.label.yOffsetUpper, 'VD');

            // Lower tracks
            drawTrackSection(layout.ad.start, layout.ad.end, layout.lowerY, 'AD');
            drawText(layout.ad.start + (layout.ad.end - layout.ad.start)/2, layout.lowerY + CONFIG.label.yOffsetLower, 'AD');

            drawTrackSection(layout.ac.start, layout.ac.end, layout.lowerY, 'AC');
            drawText(layout.ac.start + (layout.ac.end - layout.ac.start)/2, layout.lowerY + CONFIG.label.yOffsetLower, 'AC');

            // AB with switch logic
            if (state.switches['11B'] === 'NORMAL') {
                drawTrackSection(layout.ab.start, layout.ab.triangleGapX, layout.lowerY, 'AB_LEFT');
            } else {
                drawTrackSection(layout.ab.start, layout.ab.leftEnd, layout.lowerY, 'AB_LEFT');
                drawTrackSection(layout.ab.rightStart, layout.ab.triangleGapX, layout.lowerY, 'AB_RIGHT');
            }
            drawText(layout.ab.rightEnd - 60, layout.lowerY + CONFIG.label.yOffsetLower, 'AB');
            drawText(layout.ab.switch11B.start + 20, layout.lowerY + CONFIG.label.yOffsetLower, '11B');

            drawTrackSection(layout.aa.start, layout.aa.end, layout.lowerY, 'AA');
            drawText(layout.aa.start + (layout.aa.end - layout.aa.start)/2, layout.lowerY + CONFIG.label.yOffsetLower, 'AA');

            // Gaps
            [layout.vaVb1X + (CONFIG.triangle.offset - CONFIG.triangle.size),
             layout.vb.end,
             layout.vcVd1X + (CONFIG.triangle.offset - CONFIG.triangle.size)].forEach(x => {
                drawRect(x, layout.upperY - CONFIG.gap.height/2, CONFIG.gap.width, CONFIG.gap.height,
                        { fill: defaultColor(), stroke: 'none' });
                drawRect(x, layout.lowerY - CONFIG.gap.height/2, CONFIG.gap.width, CONFIG.gap.height,
                        { fill: defaultColor(), stroke: 'none' });
            });

            // Triangles
            TRIANGLES.forEach(t => {
                const x = t.x === 'vaVb1' ? layout.vaVb1X :
                         t.x === 'vaVb2' ? layout.vaVb2X :
                         t.x === 'vcVd1' ? layout.vcVd1X :
                         t.x === 'vcVd2' ? layout.vcVd2X :
                         t.x === 'adAc' ? layout.ad.end + CONFIG.triangle.size : 0;
                const y = t.y === 'upper' ? layout.upperY : layout.lowerY;
                drawTriangle(x, y, t.orientation, () => handleTriangleClick(t.signal, t.direction));
            });

            // Diagonal
            let diagX1 = layout.vc.rightStart - CONFIG.diag.offset;
            let diagY1 = layout.upperY;
            let diagX2 = layout.ab.leftEnd + CONFIG.diag.offset;
            let diagY2 = layout.lowerY;

            const dx = diagX2 - diagX1, dy = diagY2 - diagY1;
            const len = Math.sqrt(dx*dx + dy*dy);
            const ux = dx / len, uy = dy / len;

            if (state.switches['11A'] === 'NORMAL') {
                diagX1 += ux * CONFIG.switch.normalShortening;
                diagY1 += uy * CONFIG.switch.normalShortening;
            }
            if (state.switches['11B'] === 'NORMAL') {
                diagX2 -= ux * CONFIG.switch.normalShortening;
                diagY2 -= uy * CONFIG.switch.normalShortening;
            }

            const midX = (diagX1 + diagX2) / 2, midY = (diagY1 + diagY2) / 2;
            const split1X = midX - ux * CONFIG.diag.gapDistance;
            const split1Y = midY - uy * CONFIG.diag.gapDistance;
            const split2X = midX + ux * CONFIG.diag.gapDistance;
            const split2Y = midY + uy * CONFIG.diag.gapDistance;

            const cap1 = (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'NORMAL') ? 'butt' :
                        (state.switches['11A'] === 'REVERSE' && state.switches['11B'] === 'NORMAL') ? 'round' : 'butt';
            const cap2 = (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'NORMAL') ? 'butt' :
                        (state.switches['11A'] === 'NORMAL' && state.switches['11B'] === 'REVERSE') ? 'round' :
                        (state.switches['11A'] === 'REVERSE' && state.switches['11B'] === 'REVERSE') ? 'round' : 'butt';

            drawLine(diagX1, diagY1, split1X, split1Y, {
                stroke: getColor(state.tracks['DIAG']), 'stroke-width': CONFIG.track.width, 'stroke-linecap': cap1
            });
            drawLine(split2X, split2Y, diagX2, diagY2, {
                stroke: getColor(state.tracks['DIAG']), 'stroke-width': CONFIG.track.width, 'stroke-linecap': cap2
            });

            // Switch overlays
            if (state.switches['11A'] === 'NORMAL') {
                drawLine(layout.vc.switch11A.start - CONFIG.switch.overlap, layout.upperY,
                        layout.vc.switch11A.end + CONFIG.switch.overlap, layout.upperY, {
                    stroke: getColor(state.tracks['VC_LEFT']), 'stroke-width': CONFIG.track.width, 'stroke-linecap': 'butt'
                });
            }
            if (state.switchStates['11A'] === 'broken' && state.power === 'on') {
                const circle = drawCircle((layout.vc.switch11A.start + layout.vc.switch11A.end)/2, layout.upperY,
                                         CONFIG.switch.indicatorRadius, {
                    fill: 'none', stroke: COLORS.yellow, 'stroke-width': '2', cursor: 'pointer', class: 'broken-ring'
                });
                circle.onclick = () => toggleSwitchState('11A');
            }

            if (state.switches['11B'] === 'NORMAL') {
                drawLine(layout.ab.switch11B.start - CONFIG.switch.overlap, layout.lowerY,
                        layout.ab.switch11B.end + CONFIG.switch.overlap, layout.lowerY, {
                    stroke: getColor(state.tracks['AB_LEFT']), 'stroke-width': CONFIG.track.width, 'stroke-linecap': 'butt'
                });
            }
            if (state.switchStates['11B'] === 'broken' && state.power === 'on') {
                const circle = drawCircle((layout.ab.switch11B.start + layout.ab.switch11B.end)/2, layout.lowerY,
                                         CONFIG.switch.indicatorRadius, {
                    fill: 'none', stroke: COLORS.yellow, 'stroke-width': '2', cursor: 'pointer', class: 'broken-ring'
                });
                circle.onclick = () => toggleSwitchState('11B');
            }

            // Shunt symbols
            SHUNT_SYMBOLS.forEach(s => drawShuntSymbol(s, layout));

            // Platforms
            const platformTopY = layout.upperY + CONFIG.platform.yOffset;
            const platformBottomY = layout.lowerY - CONFIG.platform.yOffset;
            [
                { x: layout.va.start + (layout.va.end - layout.va.start)/2 - CONFIG.platform.labelOffset, label: 'Platform B' },
                { x: layout.vd.start + (layout.vd.end - layout.vd.start)/2 - CONFIG.platform.labelOffset, label: 'Platform A' }
            ].forEach(p => {
                drawRect(p.x, platformTopY, CONFIG.platform.width, platformBottomY - platformTopY, {
                    fill: 'none', stroke: defaultColor(), 'stroke-width': '2'
                });
                drawText(p.x + CONFIG.platform.width/2, platformTopY + (platformBottomY - platformTopY)/2, p.label);
            });

            // Signals
            SIGNALS.forEach(s => drawSignal(s, layout));

            // End labels
            drawText(layout.startX - CONFIG.label.endOffset, layout.middleY, 'SELATAN');
            drawText(layout.aa.end + CONFIG.label.endOffset, layout.middleY, 'UTARA');
        };

        // ════════════════════════════════════════════════════════════════
        // 10. STATE MANAGEMENT & CONTROLS
        // ════════════════════════════════════════════════════════════════

        const togglePower = () => {
            state.power = state.power === 'on' ? 'off' : 'on';
            updateUI();
            render();
        };

        const setMode = (mode) => {
            if (state.power === 'off') return;
            state.mode = mode;
            updateUI();
            render();
        };

        const cycleState = (trackName) => {
            if (state.power === 'off') return;
            const order = ['magenta', 'white', 'green', 'red'];
            const idx = order.indexOf(state.tracks[trackName]);
            state.tracks[trackName] = order[(idx + 1) % order.length];

            if (trackName === 'VC_LEFT' && state.switches['11A'] === 'NORMAL') {
                state.tracks['VC_RIGHT'] = state.tracks['VC_LEFT'];
                state.tracks['VC_11A'] = state.tracks['VC_LEFT'];
            }
            if (trackName === 'AB_LEFT' && state.switches['11B'] === 'NORMAL') {
                state.tracks['AB_RIGHT'] = state.tracks['AB_LEFT'];
                state.tracks['AB_11B'] = state.tracks['AB_LEFT'];
            }
            render();
        };

        const cycleSignal = (name) => {
            if (state.power === 'off') return;
            const order = ['off', 'green', 'red', 'broken'];
            const idx = order.indexOf(state.signals[name] || 'off');
            state.signals[name] = order[(idx + 1) % order.length];
            render();
        };

        const toggleSwitch = (name) => {
            if (state.power === 'off') return;
            state.switches[name] = state.switches[name] === 'NORMAL' ? 'REVERSE' : 'NORMAL';
            render();
        };

        const toggleSwitchState = (name) => {
            if (state.power === 'off') return;
            state.switchStates[name] = state.switchStates[name] === 'OK' ? 'broken' : 'OK';
            render();
        };

        const toggleHood = (name) => {
            if (state.power === 'off') return;
            state.hoods[name] = state.hoods[name] === 'empty' ? 'filled' : 'empty';
            render();
        };

        const updateUI = () => {
            const powerBtn = document.getElementById('powerBtn');
            const statusDiv = document.getElementById('systemStatus');
            const vduBtn = document.getElementById('vduBtn');
            const dominoBtn = document.getElementById('dominoBtn');

            powerBtn.textContent = state.power.toUpperCase();
            powerBtn.className = `power-button ${state.power}`;
            statusDiv.textContent = state.power === 'on'
                ? `SYSTEM: READY (${state.mode.toUpperCase()})`
                : 'SYSTEM: OFFLINE';
            statusDiv.className = `system-status ${state.power === 'off' ? 'off' : ''}`;

            vduBtn.className = state.mode === 'vdu' ? 'active' : 'inactive';
            dominoBtn.className = state.mode === 'domino' ? 'active' : 'inactive';
        };

        const updateControls = () => {
            const container = document.getElementById('trackControls');
            container.innerHTML = '';

            CONTROL_SECTIONS.forEach(section => {
                const title = document.createElement('div');
                title.className = 'section-title';
                title.textContent = section.title;
                container.appendChild(title);

                section.items.forEach(item => {
                    if (section.type === 'track' &&
                        ((item === 'VC_11A' && state.switches['11A'] === 'NORMAL') ||
                         (item === 'AB_11B' && state.switches['11B'] === 'NORMAL'))) return;

                    const div = document.createElement('div');
                    div.className = 'track-item';

                    const label = document.createElement('div');
                    label.className = 'track-name';
                    label.textContent = item.replace(/_/g, ' ') + (section.type === 'hood' ? ' Hood' : '');
                    div.appendChild(label);

                    if (section.type === 'switch') {
                        ['NORMAL', 'REVERSE'].forEach(pos => {
                            const btn = document.createElement('button');
                            btn.textContent = pos;
                            btn.className = state.switches[item] === pos ? 'active' : '';
                            btn.onclick = () => toggleSwitch(item);
                            if (!div.querySelector('.btn-group')) {
                                const group = document.createElement('div');
                                group.className = 'btn-group';
                                div.appendChild(group);
                            }
                            div.querySelector('.btn-group').appendChild(btn);
                        });
                        ['OK', 'BROKEN'].forEach(st => {
                            const btn = document.createElement('button');
                            btn.textContent = st;
                            btn.className = state.switchStates[item] === (st === 'OK' ? 'OK' : 'broken') ? 'active' : '';
                            btn.onclick = () => toggleSwitchState(item);
                            if (div.querySelectorAll('.btn-group').length < 2) {
                                const group = document.createElement('div');
                                group.className = 'btn-group';
                                div.appendChild(group);
                            }
                            div.querySelectorAll('.btn-group')[1].appendChild(btn);
                        });
                    } else if (section.type === 'hood') {
                        ['EMPTY', 'FILLED'].forEach(st => {
                            const btn = document.createElement('button');
                            btn.textContent = st;
                            btn.className = state.hoods[item] === st.toLowerCase() ? 'active' : '';
                            btn.onclick = () => { if (state.hoods[item] !== st.toLowerCase()) toggleHood(item); };
                            if (!div.querySelector('.btn-group')) {
                                const group = document.createElement('div');
                                group.className = 'btn-group';
                                div.appendChild(group);
                            }
                            div.querySelector('.btn-group').appendChild(btn);
                        });
                    } else {
                        const btn = document.createElement('button');
                        const value = section.type === 'signal' ? state.signals[item] : state.tracks[item];
                        btn.className = `track-btn ${value}`;
                        btn.textContent = value.toUpperCase();
                        btn.onclick = section.type === 'signal' ? () => cycleSignal(item) : () => cycleState(item);
                        div.appendChild(btn);
                    }

                    container.appendChild(div);
                });
            });
        };

        const render = () => {
            drawTrack();
            updateControls();
            document.querySelector('.controls').classList.toggle('disabled', state.power === 'off');
        };

        // Initialize
        document.getElementById('powerBtn').addEventListener('click', togglePower);
        document.getElementById('vduBtn').addEventListener('click', () => setMode('vdu'));
        document.getElementById('dominoBtn').addEventListener('click', () => setMode('domino'));
        render();
    </script>
</body>
</html>
